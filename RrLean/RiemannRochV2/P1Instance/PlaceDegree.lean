import RrLean.RiemannRochV2.Core.Basic
import RrLean.RiemannRochV2.Core.Divisor
import RrLean.RiemannRochV2.SerreDuality.P1Specific.RatFuncPairing
import RrLean.RiemannRochV2.Definitions.Infrastructure
import Mathlib.RingTheory.AdjoinRoot
import Mathlib.RingTheory.Polynomial.Quotient
import Mathlib.RingTheory.Coprime.Lemmas
import Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicity
import Mathlib.Algebra.Polynomial.FieldDivision

/-!
# Place Degree for Polynomial Rings

This module defines the degree of a place (HeightOneSpectrum) for polynomial rings
over a field, and proves that it equals the residue field dimension.

## Main Definitions

* `PlaceDegree.degree` - The degree of a finite place as the finrank of its residue field
* `PlaceDegree.degWeighted` - Weighted degree of a divisor

## Key Results

* `finrank_residueField_eq_degree` - The residue field dimension equals the place degree
* `linearPlace_degree_eq_one` - Linear places have degree 1

## Strategy

For P¹ = RatFunc k, places are HeightOneSpectrum (Polynomial k). Each such place
corresponds to a monic irreducible polynomial p, and:
- The residue field is k[X]/(p), which has dimension deg(p) over k
- Using Mathlib's `finrank_quotient_span_eq_natDegree`, we get the dimension directly
-/

noncomputable section

namespace RiemannRochV2

namespace PlaceDegree

open IsDedekindDomain Polynomial

variable (k : Type*) [Field k] [DecidableEq k]

/-! ## Generator of a HeightOneSpectrum -/

/-- Every HeightOneSpectrum of k[X] is principal, generated by a monic irreducible.
This is because k[X] is a PID where every prime ideal is principal.

Proof: k[X] is a PID, so v.asIdeal = span{g} for some g.
Since v.asIdeal is prime and nonzero, g is irreducible.
Normalize to monic by scaling by (leadingCoeff g)⁻¹. -/
theorem exists_generator (v : HeightOneSpectrum (Polynomial k)) :
    ∃ p : Polynomial k, p.Monic ∧ Irreducible p ∧ v.asIdeal = Ideal.span {p} := by
  -- k[X] is a PID, so the prime ideal v.asIdeal is principal
  have hprinc : v.asIdeal.IsPrincipal := IsPrincipalIdealRing.principal v.asIdeal
  obtain ⟨g, hg⟩ := hprinc.principal
  -- g ≠ 0 since v.asIdeal ≠ ⊥
  have hg_ne : g ≠ 0 := by
    intro hg0
    have : v.asIdeal = ⊥ := by
      rw [hg, hg0]
      exact Submodule.span_singleton_eq_bot.mpr rfl
    exact v.ne_bot this
  -- g is irreducible since v.asIdeal is prime and nonzero in a PID
  have hg_irr : Irreducible g := by
    have hprime : v.asIdeal.IsPrime := v.isPrime
    rw [hg] at hprime
    have hprime' := (Ideal.span_singleton_prime hg_ne).mp hprime
    exact hprime'.irreducible
  -- Normalize to monic
  let u := leadingCoeff g
  have hu_ne : u ≠ 0 := leadingCoeff_ne_zero.mpr hg_ne
  use C u⁻¹ * g
  refine ⟨?monic, ?irr, ?span⟩
  case monic =>
    unfold Monic
    rw [leadingCoeff_mul, leadingCoeff_C, inv_mul_cancel₀ hu_ne]
  case irr =>
    have hCu_unit : IsUnit (C u⁻¹ : Polynomial k) := by
      rw [isUnit_C]
      exact (inv_ne_zero hu_ne).isUnit
    exact (irreducible_isUnit_mul hCu_unit).mpr hg_irr
  case span =>
    rw [hg]
    have hCu_unit : IsUnit (C u⁻¹ : Polynomial k) := by
      rw [isUnit_C]
      exact (inv_ne_zero hu_ne).isUnit
    -- span{C u⁻¹ * g} = span{g} since C u⁻¹ is a unit
    -- Convert Ideal.span to Submodule.span notation (they are equal by definition)
    simp only [← Ideal.submodule_span_eq]
    -- Now both sides are k[X] ∙ _, use span_singleton_eq_span_singleton
    rw [Submodule.span_singleton_eq_span_singleton]
    -- Need: ∃ z : (Polynomial k)ˣ, z • g = C u⁻¹ * g
    refine ⟨hCu_unit.unit, ?_⟩
    rw [Units.smul_def, IsUnit.unit_spec, smul_eq_mul]

/-- Choose a generator for a HeightOneSpectrum (monic irreducible polynomial). -/
noncomputable def generator (v : HeightOneSpectrum (Polynomial k)) : Polynomial k :=
  (exists_generator k v).choose

lemma generator_monic (v : HeightOneSpectrum (Polynomial k)) : (generator k v).Monic :=
  (exists_generator k v).choose_spec.1

lemma generator_irreducible (v : HeightOneSpectrum (Polynomial k)) : Irreducible (generator k v) :=
  (exists_generator k v).choose_spec.2.1

lemma asIdeal_eq_span_generator (v : HeightOneSpectrum (Polynomial k)) :
    v.asIdeal = Ideal.span {generator k v} :=
  (exists_generator k v).choose_spec.2.2

/-! ## Place Degree -/

/-- The degree of a finite place on Polynomial k is the natDegree of its generator.
This equals the residue field dimension [κ(v) : k]. -/
def degree (v : HeightOneSpectrum (Polynomial k)) : ℕ :=
  (generator k v).natDegree

/-- The degree is at least 1 for any place.

Proof: The generator is irreducible, and irreducible polynomials have degree ≥ 1.
Over a field, degree 0 polynomials are units, contradicting irreducibility. -/
lemma degree_pos (v : HeightOneSpectrum (Polynomial k)) : 0 < degree k v := by
  unfold degree
  have hirr := generator_irreducible k v
  -- Irreducible polynomials over a field have degree ≥ 1
  exact hirr.natDegree_pos

/-- Linear places have degree 1.

Proof: The generator and X - C α generate the same ideal, so they are associated.
Both are monic, so they must be equal. X - C α has natDegree 1. -/
lemma linearPlace_degree_eq_one (α : k) :
    degree k (linearPlace α) = 1 := by
  unfold degree
  have hgen := asIdeal_eq_span_generator k (linearPlace α)
  have hlin : (linearPlace α).asIdeal = Ideal.span {X - C α} := rfl
  rw [hlin] at hgen
  -- span{generator} = span{X - C α}, so they are associated
  have hassoc : Associated (generator k (linearPlace α)) (X - C α) := by
    rw [← Ideal.span_singleton_eq_span_singleton]
    exact hgen.symm
  have hmonic_gen := generator_monic k (linearPlace α)
  have hmonic_lin : (X - C α : Polynomial k).Monic := monic_X_sub_C α
  -- Associated monic polynomials are equal
  have heq : generator k (linearPlace α) = X - C α :=
    eq_of_monic_of_associated hmonic_gen hmonic_lin hassoc
  rw [heq, natDegree_X_sub_C]

/-- Places of degree 1 are linear places.

Proof: If degree(v) = 1, then generator(v) has natDegree 1.
Over a field, monic polynomials of degree 1 are of the form X - C α,
so v = linearPlace α for some α ∈ k.

This is the converse of `linearPlace_degree_eq_one`. -/
lemma linear_of_degree_eq_one (v : HeightOneSpectrum (Polynomial k)) (hdeg : degree k v = 1) :
    ∃ α : k, v = linearPlace α := by
  -- The generator has natDegree 1
  have hgen_monic := generator_monic k v
  have hgen_deg : (generator k v).natDegree = 1 := hdeg
  -- Monic degree-1 polynomial is X + C b for some b
  have hform := hgen_monic.eq_X_add_C hgen_deg
  -- Let α = -b, so generator = X - C α
  use -(generator k v).coeff 0
  -- v.asIdeal = span{generator} = span{X - C α} = (linearPlace α).asIdeal
  apply HeightOneSpectrum.ext
  rw [asIdeal_eq_span_generator k v, hform]
  -- Now goal is: span{X + C b} = span{X - C (-b)}
  -- These are equal since X + C b = X - C (-b)
  congr 1
  -- Goal: X + C b = X + C ((X + C b).coeff 0), but (X + C b).coeff 0 = b
  simp only [Set.singleton_eq_singleton_iff, map_neg, sub_neg_eq_add, coeff_add, coeff_X_zero,
             coeff_C_zero, zero_add]

/-! ## Finrank of Residue Field -/

/-- The residue field of a place v has finrank equal to the place degree.
This uses Mathlib's `finrank_quotient_span_eq_natDegree`. -/
theorem finrank_residueField_eq_degree (v : HeightOneSpectrum (Polynomial k)) :
    Module.finrank k (Polynomial k ⧸ v.asIdeal) = degree k v := by
  rw [asIdeal_eq_span_generator k v]
  exact finrank_quotient_span_eq_natDegree

/-! ## Weighted Degree -/

/-- The weighted degree of a divisor, taking place degrees into account.
For D = Σ nᵥ · [v], this is Σ nᵥ · deg(v). -/
def degWeighted (D : DivisorV2 (Polynomial k)) : ℤ :=
  D.sum (fun v n => n * (degree k v : ℤ))

/-- For linear places, weighted degree equals unweighted degree. -/
lemma degWeighted_eq_deg_of_linear {D : DivisorV2 (Polynomial k)}
    (hlin : ∀ v ∈ D.support, degree k v = 1) :
    degWeighted k D = D.deg := by
  unfold degWeighted DivisorV2.deg
  apply Finsupp.sum_congr
  intro v hv
  rw [hlin v hv, Nat.cast_one, mul_one]

/-- Weighted degree of a single-place divisor. -/
lemma degWeighted_single (v : HeightOneSpectrum (Polynomial k)) (n : ℤ) :
    degWeighted k (DivisorV2.single v n) = n * (degree k v : ℤ) := by
  unfold degWeighted DivisorV2.single
  rw [Finsupp.sum_single_index (by ring)]

/-- Weighted degree is additive. -/
lemma degWeighted_add (D E : DivisorV2 (Polynomial k)) :
    degWeighted k (D + E) = degWeighted k D + degWeighted k E := by
  unfold degWeighted
  rw [Finsupp.sum_add_index']
  · intro v; ring
  · intro v n₁ n₂; ring

/-- Weighted degree of negation. -/
lemma degWeighted_neg (D : DivisorV2 (Polynomial k)) :
    degWeighted k (-D) = -degWeighted k D := by
  unfold degWeighted
  rw [Finsupp.sum_neg_index]
  · simp only [neg_mul, Finsupp.sum_neg]
  · intro _; ring

/-- Weighted degree is subtractive. -/
lemma degWeighted_sub (D E : DivisorV2 (Polynomial k)) :
    degWeighted k (D - E) = degWeighted k D - degWeighted k E := by
  rw [sub_eq_add_neg, degWeighted_add, degWeighted_neg, sub_eq_add_neg]

/-! ## Coprimality of Distinct Primes -/

/-- The generator of one prime is not in another prime ideal for distinct primes.

In k[X], distinct HeightOneSpectrum correspond to distinct monic irreducibles.
These generate coprime ideals. -/
lemma generator_not_mem_other_prime (v w : HeightOneSpectrum (Polynomial k))
    (hw : w ≠ v) : generator k v ∉ w.asIdeal := by
  -- If generator k v ∈ w.asIdeal, then v.asIdeal ⊆ w.asIdeal
  intro hgen_mem_w
  -- v.asIdeal = span{generator k v} ⊆ w.asIdeal
  have hv_le_w : v.asIdeal ≤ w.asIdeal := by
    rw [asIdeal_eq_span_generator k v]
    exact Ideal.span_le.mpr (Set.singleton_subset_iff.mpr hgen_mem_w)
  -- v.asIdeal is maximal (height-1 prime in k[X] is maximal)
  have hv_max := v.isMaximal
  -- w.asIdeal is prime and ≠ ⊤
  have hw_prime := w.isPrime
  -- By maximality: v.asIdeal ≤ w.asIdeal and w ≠ ⊤ implies v.asIdeal = w.asIdeal
  have heq : v.asIdeal = w.asIdeal := hv_max.eq_of_le hw_prime.ne_top hv_le_w
  -- But v.asIdeal ≠ w.asIdeal since hw : w ≠ v
  exact hw (HeightOneSpectrum.ext heq.symm)

/-- The generator of v has valuation 1 at other primes w ≠ v. -/
lemma generator_intValuation_at_other_prime (v w : HeightOneSpectrum (Polynomial k))
    (hw : w ≠ v) : w.intValuation (generator k v) = 1 := by
  rw [HeightOneSpectrum.intValuation_eq_one_iff]
  exact generator_not_mem_other_prime k v w hw

/-- The generator of v has v-adic valuation exp(-1).

This is the key lemma that connects generators to uniformizers.
Since v.asIdeal = span{generator}, and intValuation_singleton says
the valuation of a generator of the ideal is exp(-1), we're done. -/
lemma generator_intValuation_at_self (v : HeightOneSpectrum (Polynomial k)) :
    v.intValuation (generator k v) = WithZero.exp (-1 : ℤ) := by
  have hgen_ne : generator k v ≠ 0 := (generator_irreducible k v).ne_zero
  have hspan := asIdeal_eq_span_generator k v
  exact v.intValuation_singleton hgen_ne hspan

/-! ## Uniformizer-Generator Relationship

The abstract `uniformizerAt v` from Infrastructure.lean is defined as ANY element with
v.intValuation = exp(-1). In k[X], this could be `generator(v) * w` for some polynomial w
coprime to gen. The following lemmas establish the relationship needed for the
evaluation map surjectivity proof. -/

/-- The uniformizer is in v.asIdeal (has valuation < 1). -/
lemma uniformizerAt_mem_asIdeal (v : HeightOneSpectrum (Polynomial k)) :
    uniformizerAt v ∈ v.asIdeal := by
  rw [← v.intValuation_lt_one_iff_mem, uniformizerAt_val]
  -- exp(-1) < exp(0) = 1
  exact WithZero.exp_lt_exp.mpr (by norm_num : (-1 : ℤ) < 0)

/-- The uniformizer is not in v.asIdeal² (has valuation exactly exp(-1), not exp(-2)). -/
lemma uniformizerAt_not_mem_asIdeal_sq (v : HeightOneSpectrum (Polynomial k)) :
    uniformizerAt v ∉ v.asIdeal ^ 2 := by
  intro h
  have hval := uniformizerAt_val v
  -- If π ∈ v.asIdeal², then v(π) ≤ exp(-2)
  have hval_le : v.intValuation (uniformizerAt v) ≤ WithZero.exp (-2 : ℤ) :=
    (v.intValuation_le_pow_iff_mem (uniformizerAt v) 2).mpr h
  rw [hval] at hval_le
  -- exp(-1) ≤ exp(-2) is false since -1 > -2
  have hcontra : (-1 : ℤ) ≤ -2 := WithZero.exp_le_exp.mp hval_le
  omega

/-- The generator divides the uniformizer in k[X]. -/
lemma generator_dvd_uniformizerAt (v : HeightOneSpectrum (Polynomial k)) :
    generator k v ∣ uniformizerAt v := by
  have hmem := uniformizerAt_mem_asIdeal k v
  rw [asIdeal_eq_span_generator k v, Ideal.mem_span_singleton] at hmem
  exact hmem

/-- The quotient w = uniformizerAt / generator (using polynomial division). -/
noncomputable def uniformizerQuotient (v : HeightOneSpectrum (Polynomial k)) : Polynomial k :=
  uniformizerAt v /ₘ generator k v

/-- Key: uniformizerAt = generator * uniformizerQuotient. -/
lemma uniformizerAt_eq_generator_mul_quotient (v : HeightOneSpectrum (Polynomial k)) :
    uniformizerAt v = generator k v * uniformizerQuotient k v := by
  have hmonic := generator_monic k v
  have hdvd := generator_dvd_uniformizerAt k v
  rw [uniformizerQuotient]
  -- For monic divisor, p %ₘ d + d * (p /ₘ d) = p, and when d | p, p %ₘ d = 0
  have hmod_zero : uniformizerAt v %ₘ generator k v = 0 := by
    rw [Polynomial.modByMonic_eq_zero_iff_dvd hmonic]
    exact hdvd
  have hdiv := Polynomial.modByMonic_add_div (uniformizerAt v) hmonic
  -- hdiv : uniformizerAt v %ₘ gen + gen * (uniformizerAt v /ₘ gen) = uniformizerAt v
  rw [hmod_zero, zero_add] at hdiv
  exact hdiv.symm

/-- The quotient w is not in v.asIdeal (equivalently, gcd(w, gen) = 1). -/
lemma uniformizerQuotient_not_mem_asIdeal (v : HeightOneSpectrum (Polynomial k)) :
    uniformizerQuotient k v ∉ v.asIdeal := by
  intro hw_mem
  apply uniformizerAt_not_mem_asIdeal_sq k v
  rw [uniformizerAt_eq_generator_mul_quotient k v]
  -- gen * w ∈ v.asIdeal² when w ∈ v.asIdeal
  rw [pow_two]
  apply Ideal.mul_mem_mul
  · rw [asIdeal_eq_span_generator k v]
    exact Ideal.mem_span_singleton_self _
  · exact hw_mem

/-- The quotient w is nonzero. -/
lemma uniformizerQuotient_ne_zero (v : HeightOneSpectrum (Polynomial k)) :
    uniformizerQuotient k v ≠ 0 := by
  intro hw_zero
  have heq := uniformizerAt_eq_generator_mul_quotient k v
  rw [hw_zero, mul_zero] at heq
  exact uniformizerAt_ne_zero v heq

/-- In K = RatFunc k, uniformizerAt / generator = uniformizerQuotient. -/
lemma uniformizerAt_div_generator_eq_quotient (v : HeightOneSpectrum (Polynomial k)) :
    algebraMap (Polynomial k) (RatFunc k) (uniformizerAt v) /
    algebraMap (Polynomial k) (RatFunc k) (generator k v) =
    algebraMap (Polynomial k) (RatFunc k) (uniformizerQuotient k v) := by
  have hgen_ne : (generator k v) ≠ 0 := (generator_irreducible k v).ne_zero
  have hgen_K_ne : algebraMap (Polynomial k) (RatFunc k) (generator k v) ≠ 0 :=
    RatFunc.algebraMap_ne_zero hgen_ne
  rw [uniformizerAt_eq_generator_mul_quotient k v, map_mul]
  field_simp

/-- The residue of uniformizerQuotient in κ(v) is nonzero (hence invertible). -/
lemma uniformizerQuotient_residue_ne_zero (v : HeightOneSpectrum (Polynomial k)) :
    Ideal.Quotient.mk v.asIdeal (uniformizerQuotient k v) ≠ 0 := by
  rw [ne_eq, Ideal.Quotient.eq_zero_iff_mem]
  exact uniformizerQuotient_not_mem_asIdeal k v

/-! ## Valuation-Degree Relationship

The key lemmas connecting valuations at places to polynomial degrees.
For polynomial p over field k:
- val_v(p) ≤ exp(-n) iff generator_v^n | p
- If generator_v^n | p, then p.natDegree ≥ n * deg(v)
-/

/-- The n-th power of v.asIdeal equals span{generator^n}. -/
lemma asIdeal_pow_eq_span_generator_pow (v : HeightOneSpectrum (Polynomial k)) (n : ℕ) :
    v.asIdeal ^ n = Ideal.span {generator k v ^ n} := by
  rw [asIdeal_eq_span_generator k v, Ideal.span_singleton_pow]

/-- Membership in v.asIdeal^n is equivalent to generator^n dividing the element. -/
lemma mem_asIdeal_pow_iff_generator_pow_dvd (v : HeightOneSpectrum (Polynomial k))
    (p : Polynomial k) (n : ℕ) :
    p ∈ v.asIdeal ^ n ↔ generator k v ^ n ∣ p := by
  rw [asIdeal_pow_eq_span_generator_pow k v n, Ideal.mem_span_singleton]

/-- If g^n divides p (g monic, p nonzero), then p.natDegree ≥ n * g.natDegree. -/
lemma natDegree_ge_of_pow_dvd {g p : Polynomial k} (hg_monic : g.Monic)
    (hp_ne : p ≠ 0) (n : ℕ) (hdvd : g ^ n ∣ p) :
    p.natDegree ≥ n * g.natDegree := by
  obtain ⟨q, hpq⟩ := hdvd
  have hq_ne : q ≠ 0 := by
    intro hq0
    rw [hq0, mul_zero] at hpq
    exact hp_ne hpq
  have hgn_monic : (g ^ n).Monic := hg_monic.pow n
  have hgn_ne : g ^ n ≠ 0 := hgn_monic.ne_zero
  calc p.natDegree = (g ^ n * q).natDegree := by rw [hpq]
    _ = (g ^ n).natDegree + q.natDegree := by
        rw [natDegree_mul hgn_ne hq_ne]
    _ ≥ (g ^ n).natDegree := Nat.le_add_right _ _
    _ = n * g.natDegree := by rw [natDegree_pow]

/-- Key lemma: If val_v(p) ≤ exp(-n), then p.natDegree ≥ n * deg(v).

This connects the v-adic valuation to polynomial degree bounds. -/
lemma natDegree_ge_of_intValuation_le (v : HeightOneSpectrum (Polynomial k))
    (p : Polynomial k) (hp_ne : p ≠ 0) (n : ℕ)
    (hval : v.intValuation p ≤ WithZero.exp (-(n : ℤ))) :
    p.natDegree ≥ n * degree k v := by
  -- Valuation bound implies membership in ideal power
  rw [v.intValuation_le_pow_iff_mem] at hval
  -- Membership in ideal power implies generator^n divides p
  rw [mem_asIdeal_pow_iff_generator_pow_dvd] at hval
  -- Apply the degree bound lemma
  exact natDegree_ge_of_pow_dvd k (generator_monic k v) hp_ne n hval

/-- For effective divisors, degWeighted ≥ deg since all place degrees are ≥ 1. -/
lemma degWeighted_ge_deg (D : DivisorV2 (Polynomial k)) (hD_eff : D.Effective) :
    degWeighted k D ≥ D.deg := by
  unfold degWeighted DivisorV2.deg
  apply Finsupp.sum_le_sum
  intro v _
  have hdeg_pos : degree k v ≥ 1 := degree_pos k v
  have hDv : D v ≥ 0 := hD_eff v
  have hdeg_ge_one : (degree k v : ℤ) ≥ 1 := by simp only [ge_iff_le]; omega
  calc D v * (degree k v : ℤ)
      ≥ D v * 1 := by
        apply mul_le_mul_of_nonneg_left hdeg_ge_one hDv
    _ = D v := by ring

/-- Sum version: If val_v(p) ≤ exp(-D(v)) for all v in support of D,
then p.natDegree ≥ D.degWeighted (sum of D(v) * deg(v)).

This is the key lemma for proving L(K-D) vanishing.

Proof sketch: Each valuation bound val_v(p) ≤ exp(-D(v)) means gen_v^{D(v)} | p.
Since generators at different places are coprime, their product divides p.
The degree of this product equals degWeighted k D, giving the bound. -/
lemma natDegree_ge_degWeighted_of_valuation_bounds (D : DivisorV2 (Polynomial k))
    (hD_eff : D.Effective) (p : Polynomial k) (hp_ne : p ≠ 0)
    (hval : ∀ v ∈ D.support, v.intValuation p ≤ WithZero.exp (-(D v : ℤ))) :
    (p.natDegree : ℤ) ≥ degWeighted k D := by
  -- First, if D.support is empty, degWeighted = 0 and the bound is trivial
  by_cases hsupp : D.support = ∅
  · rw [Finsupp.support_eq_empty] at hsupp
    simp only [hsupp, degWeighted, Finsupp.sum_zero_index]
    exact Nat.cast_nonneg _
  -- For nonempty support: each gen_v^{D(v)} divides p (from valuation bound)
  have hdvd_each : ∀ v ∈ D.support, generator k v ^ (D v).toNat ∣ p := by
    intro v hv
    have hDv_pos : D v ≥ 0 := hD_eff v
    have hval_v := hval v hv
    -- Convert: D v = (D v).toNat as integers when D v ≥ 0
    have hDv_eq : (D v : ℤ) = ((D v).toNat : ℤ) := (Int.toNat_of_nonneg hDv_pos).symm
    rw [hDv_eq] at hval_v
    rw [v.intValuation_le_pow_iff_mem, mem_asIdeal_pow_iff_generator_pow_dvd] at hval_v
    exact hval_v
  -- Generators at different places are coprime
  have hcoprime_gen : ∀ v ∈ D.support, ∀ w ∈ D.support, v ≠ w →
      IsCoprime (generator k v) (generator k w) := by
    intro v _ w _ hvw
    -- generator k v ∉ w.asIdeal, so generator k w ∤ generator k v
    have hnotdvd : ¬(generator k w ∣ generator k v) := by
      intro hdvd
      have hmem : generator k v ∈ w.asIdeal := by
        rw [asIdeal_eq_span_generator k w, Ideal.mem_span_singleton]
        exact hdvd
      exact generator_not_mem_other_prime k v w hvw.symm hmem
    -- Distinct irreducibles are coprime
    exact isCoprime_comm.mp ((generator_irreducible k w).coprime_iff_not_dvd.mpr hnotdvd)
  -- Powers of coprime elements are coprime
  have hcoprime_pow : (D.support : Set (HeightOneSpectrum (Polynomial k))).Pairwise
      (fun v w => IsCoprime (generator k v ^ (D v).toNat) (generator k w ^ (D w).toNat)) := by
    intro v hv w hw hvw
    exact (hcoprime_gen v hv w hw hvw).pow
  -- Product of coprime divisors divides p
  have hprod_dvd : (∏ v ∈ D.support, generator k v ^ (D v).toNat) ∣ p :=
    Finset.prod_dvd_of_coprime hcoprime_pow hdvd_each
  -- Product is monic
  have hprod_monic : (∏ v ∈ D.support, generator k v ^ (D v).toNat).Monic :=
    monic_prod_of_monic _ _ (fun v _ => (generator_monic k v).pow (D v).toNat)
  -- Degree of product = sum of degrees
  have hdeg_prod : (∏ v ∈ D.support, generator k v ^ (D v).toNat).natDegree =
      ∑ v ∈ D.support, (generator k v ^ (D v).toNat).natDegree :=
    natDegree_prod_of_monic _ _ (fun v _ => (generator_monic k v).pow (D v).toNat)
  -- Each term: natDegree(gen^n) = n * natDegree(gen) = n * deg(v)
  have hdeg_pow : ∀ v ∈ D.support, (generator k v ^ (D v).toNat).natDegree =
      (D v).toNat * degree k v := fun v _ => natDegree_pow _ _
  -- Sum of natDegrees = degWeighted (via cast to ℤ)
  have hprod_deg : ((∏ v ∈ D.support, generator k v ^ (D v).toNat).natDegree : ℤ) =
      degWeighted k D := by
    rw [hdeg_prod]
    unfold degWeighted
    rw [Finsupp.sum]
    simp only [Nat.cast_sum]
    apply Finset.sum_congr rfl
    intro v hv
    rw [hdeg_pow v hv]
    have hDv_pos : D v ≥ 0 := hD_eff v
    simp only [Nat.cast_mul, Int.toNat_of_nonneg hDv_pos]
  -- Final bound: p.natDegree ≥ product.natDegree = degWeighted
  obtain ⟨q, hpq⟩ := hprod_dvd
  have hq_ne : q ≠ 0 := by
    intro hq0
    rw [hq0, mul_zero] at hpq
    exact hp_ne hpq
  have hprod_ne : (∏ v ∈ D.support, generator k v ^ (D v).toNat) ≠ 0 := hprod_monic.ne_zero
  have hge : p.natDegree ≥ (∏ v ∈ D.support, generator k v ^ (D v).toNat).natDegree := by
    calc p.natDegree
        = ((∏ v ∈ D.support, generator k v ^ (D v).toNat) * q).natDegree := by rw [← hpq]
      _ = (∏ v ∈ D.support, generator k v ^ (D v).toNat).natDegree + q.natDegree := by
          rw [natDegree_mul hprod_ne hq_ne]
      _ ≥ (∏ v ∈ D.support, generator k v ^ (D v).toNat).natDegree := Nat.le_add_right _ _
  calc (p.natDegree : ℤ)
      ≥ (∏ v ∈ D.support, generator k v ^ (D v).toNat).natDegree := by exact_mod_cast hge
    _ = degWeighted k D := hprod_deg

/-! ## Polynomial Degree as Sum of Multiplicities

The fundamental theorem relating polynomial degree to place multiplicities.
For p ≠ 0: p.natDegree = Σ_v ord_v(p) * deg(v)

This comes from unique factorization: p = u * ∏_v generator(v)^{ord_v(p)}
where u is the leading coefficient (a unit in k).
-/

/-- For any nonzero polynomial p, there exists n such that generator(v)^n ∤ p.

This is needed to define the order (multiplicity) as a Nat.find.
Proof: natDegree(generator(v)^n) = n * degree(v) grows without bound,
but natDegree(p) is fixed, so eventually gen^n cannot divide p. -/
lemma exists_pow_generator_not_dvd (v : HeightOneSpectrum (Polynomial k))
    (p : Polynomial k) (hp : p ≠ 0) :
    ∃ n : ℕ, ¬(generator k v ^ n ∣ p) := by
  -- For large enough n, natDegree(gen^n) > natDegree(p), so gen^n ∤ p
  use p.natDegree + 1
  intro hdvd
  have hgen_monic := generator_monic k v
  have hdeg_pos := degree_pos k v
  have hbound := natDegree_ge_of_pow_dvd k hgen_monic hp (p.natDegree + 1) hdvd
  -- hbound: p.natDegree ≥ (p.natDegree + 1) * degree k v ≥ p.natDegree + 1
  have h1 : (p.natDegree + 1) * degree k v ≥ p.natDegree + 1 :=
    Nat.le_mul_of_pos_right (p.natDegree + 1) hdeg_pos
  have h2 : p.natDegree ≥ p.natDegree + 1 := Nat.le_trans h1 hbound
  exact Nat.not_succ_le_self p.natDegree h2

/-- The order (multiplicity) of a polynomial at a place v.

For p ≠ 0, this is the largest n such that generator(v)^n | p.
For p = 0, we define ord = 0 (though valuation is infinite).

This uses the divisibility-based definition which is more constructive
than the Associates.count approach for Polynomial k.

Implementation: Nat.find gives the first n where gen^n ∤ p. Since gen^0 = 1 always
divides nonzero p, Nat.find ≥ 1. We subtract 1 to get the multiplicity. -/
noncomputable def ord (v : HeightOneSpectrum (Polynomial k)) (p : Polynomial k) : ℕ :=
  if hp : p = 0 then 0
  else @Nat.find (fun n => ¬(generator k v ^ n ∣ p)) (Classical.decPred _)
    (exists_pow_generator_not_dvd k v p hp) - 1

/-- At the generator's own place, ord = 1. -/
lemma ord_generator_self (v : HeightOneSpectrum (Polynomial k)) :
    ord k v (generator k v) = 1 := by
  -- Unfold definition: ord = Nat.find(...) - 1
  unfold ord
  -- generator is nonzero (irreducible)
  have hgen_ne : generator k v ≠ 0 := (generator_irreducible k v).ne_zero
  simp only [hgen_ne, ↓reduceDIte]
  -- Add decidability instance for Nat.find lemmas
  haveI : DecidablePred (fun n => ¬(generator k v ^ n ∣ generator k v)) := Classical.decPred _
  -- Need to show: Nat.find(...) - 1 = 1, i.e., Nat.find(...) = 2
  -- Upper bound: Nat.find ≤ 2 because gen² ∤ gen
  have hgen_sq_not_dvd : ¬(generator k v ^ 2 ∣ generator k v) := by
    intro hdvd_sq
    have hirr := generator_irreducible k v
    rw [pow_two] at hdvd_sq
    obtain ⟨q, hq⟩ := hdvd_sq
    rw [mul_assoc] at hq
    have h1 : generator k v * 1 = generator k v * (generator k v * q) := by
      rw [mul_one]; exact hq
    have h2 : (1 : Polynomial k) = generator k v * q := mul_left_cancel₀ hgen_ne h1
    have hdvd_one : generator k v ∣ 1 := ⟨q, h2⟩
    exact hirr.not_isUnit (isUnit_of_dvd_one hdvd_one)
  have hle : Nat.find (exists_pow_generator_not_dvd k v (generator k v) hgen_ne) ≤ 2 :=
    Nat.find_min' _ hgen_sq_not_dvd
  -- Lower bound: 2 ≤ Nat.find because gen^0 | gen and gen^1 | gen
  have hge : 2 ≤ Nat.find (exists_pow_generator_not_dvd k v (generator k v) hgen_ne) := by
    rw [Nat.le_find_iff]
    intro m hm
    push_neg
    interval_cases m
    · simp only [pow_zero, one_dvd]
    · simp only [pow_one, dvd_refl]
  -- Combine bounds: find = 2
  have heq : Nat.find (exists_pow_generator_not_dvd k v (generator k v) hgen_ne) = 2 :=
    Nat.le_antisymm hle hge
  -- Goal: @Nat.find _ (Classical.decPred _) _ - 1 = 1
  -- The two Nat.find have the same predicate, just different instances.
  -- Use Nat.find_congr' to unify them (predicate is definitionally equal).
  have heq' : @Nat.find _ (Classical.decPred _) (exists_pow_generator_not_dvd k v (generator k v) hgen_ne) = 2 := by
    convert heq using 2
  rw [heq']

/-- At a different place, ord of generator = 0. -/
lemma ord_generator_other (v w : HeightOneSpectrum (Polynomial k)) (hw : w ≠ v) :
    ord k w (generator k v) = 0 := by
  -- Unfold definition: ord = Nat.find(...) - 1
  unfold ord
  -- generator v is nonzero
  have hgen_v_ne : generator k v ≠ 0 := (generator_irreducible k v).ne_zero
  simp only [hgen_v_ne, ↓reduceDIte]
  -- Add decidability instance for Nat.find lemmas
  haveI : DecidablePred (fun n => ¬(generator k w ^ n ∣ generator k v)) := Classical.decPred _
  -- Need to show: Nat.find(...) - 1 = 0, i.e., Nat.find(...) = 1
  -- Upper bound: Nat.find ≤ 1 because gen(w) ∤ gen(v) (by coprimality)
  have hgen_w_not_dvd : ¬(generator k w ∣ generator k v) := by
    intro hdvd
    have hmem : generator k v ∈ w.asIdeal := by
      rw [asIdeal_eq_span_generator k w, Ideal.mem_span_singleton]
      exact hdvd
    exact generator_not_mem_other_prime k v w hw hmem
  have hle : Nat.find (exists_pow_generator_not_dvd k w (generator k v) hgen_v_ne) ≤ 1 := by
    apply Nat.find_min'
    simpa only [pow_one] using hgen_w_not_dvd
  -- Lower bound: 1 ≤ Nat.find because gen(w)^0 = 1 | gen(v)
  have hge : 1 ≤ Nat.find (exists_pow_generator_not_dvd k w (generator k v) hgen_v_ne) := by
    rw [Nat.le_find_iff]
    intro m hm
    interval_cases m
    simp only [pow_zero, one_dvd, not_true_eq_false, not_false_eq_true]
  -- Combine bounds: find = 1
  have heq : Nat.find (exists_pow_generator_not_dvd k w (generator k v) hgen_v_ne) = 1 :=
    Nat.le_antisymm hle hge
  -- Goal: @Nat.find _ (Classical.decPred _) _ - 1 = 0
  have heq' : @Nat.find _ (Classical.decPred _) (exists_pow_generator_not_dvd k w (generator k v) hgen_v_ne) = 1 := by
    convert heq using 2
  rw [heq']

/-! ## Normalized Factors and Ord -/

/-- Generators are normalized (monic polynomials are normalized). -/
lemma generator_normalize (v : HeightOneSpectrum (Polynomial k)) :
    normalize (generator k v) = generator k v :=
  (generator_monic k v).normalize_eq_self

/-- generator(v)^n divides p iff n ≤ ord(v, p).

This is the key divisibility characterization of ord. The proof uses Nat.find properties
but requires careful Nat arithmetic that's deferred to a later cycle. -/
lemma pow_generator_dvd_iff_le_ord (v : HeightOneSpectrum (Polynomial k))
    (p : Polynomial k) (hp : p ≠ 0) (n : ℕ) :
    generator k v ^ n ∣ p ↔ n ≤ ord k v p := by
  -- The proof relies on Nat.find properties:
  -- ord = (Nat.find ...) - 1, so n ≤ ord iff n < Nat.find iff gen^n | p
  -- This is straightforward but requires careful Nat subtraction handling
  sorry

/-- The ord equals the count of the generator in normalized factors.

This connects our divisibility-based definition to Mathlib's normalized factor machinery. -/
lemma ord_eq_count_normalizedFactors (v : HeightOneSpectrum (Polynomial k))
    (p : Polynomial k) (hp : p ≠ 0) :
    ord k v p = (UniqueFactorizationMonoid.normalizedFactors p).count (generator k v) := by
  -- Use count_normalizedFactors_eq: count = n iff p^n | x and p^{n+1} ∤ x
  symm
  apply UniqueFactorizationMonoid.count_normalizedFactors_eq
  · exact generator_irreducible k v
  · exact generator_normalize k v
  · exact (pow_generator_dvd_iff_le_ord k v p hp _).mpr le_rfl
  · rw [pow_generator_dvd_iff_le_ord k v p hp]
    omega

/-- For each monic irreducible q, there exists a unique place v with generator k v = q. -/
lemma exists_place_with_generator (q : Polynomial k) (hq_monic : q.Monic) (hq_irr : Irreducible q) :
    ∃! v : HeightOneSpectrum (Polynomial k), generator k v = q := by
  -- The place is the one with asIdeal = span{q}
  have hq_ne : q ≠ 0 := hq_monic.ne_zero
  have hq_prime : Prime q := hq_irr.prime
  -- span{q} is a prime ideal (since q is prime)
  have hprime_ideal : (Ideal.span {q}).IsPrime := by
    rwa [Ideal.span_singleton_prime hq_ne]
  -- span{q} ≠ ⊥ since q ≠ 0
  have hne_bot : Ideal.span {q} ≠ ⊥ := by
    simp only [ne_eq, Ideal.span_singleton_eq_bot, hq_ne, not_false_eq_true]
  -- In a PID, nonzero prime ideals are height-one (maximal among proper)
  have hmaximal : (Ideal.span {q}).IsMaximal := by
    apply Ideal.IsPrime.isMaximal hprime_ideal
    exact hne_bot
  -- Construct the HeightOneSpectrum
  let v : HeightOneSpectrum (Polynomial k) := ⟨Ideal.span {q}, hprime_ideal, hne_bot⟩
  use v
  constructor
  · -- generator k v = q
    -- generator k v generates the same ideal: span{generator k v} = v.asIdeal = span{q}
    have hgen_span := asIdeal_eq_span_generator k v
    -- So generator k v and q are associates (both generate span{q})
    have hassoc : Associated (generator k v) q := by
      rw [← Ideal.span_singleton_eq_span_singleton]
      exact hgen_span.symm
    -- Both are monic, so they're equal
    exact eq_of_monic_of_associated (generator_monic k v) hq_monic hassoc
  · -- Uniqueness: if generator k w = q, then w = v
    intro w hw
    apply HeightOneSpectrum.ext
    rw [asIdeal_eq_span_generator k w, hw]

/-- The natDegree of the product of normalized factors equals the natDegree of p. -/
lemma natDegree_normalizedFactors_prod (p : Polynomial k) (hp : p ≠ 0) :
    (UniqueFactorizationMonoid.normalizedFactors p).prod.natDegree = p.natDegree := by
  -- prod(normalizedFactors p) = normalize p (by prod_normalizedFactors_eq)
  have hprod := UniqueFactorizationMonoid.prod_normalizedFactors_eq hp
  -- hprod : (normalizedFactors p).prod = normalize p
  rw [hprod]
  -- Use leadingCoeff_mul_prod_normalizedFactors: C a.leadingCoeff * (normalizedFactors a).prod = a
  haveI : DecidableEq (Polynomial k) := Classical.decEq _
  -- degree (normalize p) = degree p, so natDegree as well
  simp only [natDegree_eq_of_degree_eq Polynomial.degree_normalize]

/-- Normalized factors of a polynomial are monic. -/
lemma monic_of_mem_normalizedFactors (p : Polynomial k) {q : Polynomial k}
    (hq : q ∈ UniqueFactorizationMonoid.normalizedFactors p) : q.Monic := by
  have hnorm := UniqueFactorizationMonoid.normalize_normalized_factor q hq
  -- hnorm : normalize q = q
  -- For polynomials, normalize q = q iff q is monic (when q ≠ 0)
  have hq_ne : q ≠ 0 := (UniqueFactorizationMonoid.irreducible_of_normalized_factor q hq).ne_zero
  haveI : DecidableEq (Polynomial k) := Classical.decEq _
  rwa [← Polynomial.normalize_eq_self_iff_monic hq_ne]

/-- The natDegree of the product of normalized factors equals the sum of natDegrees. -/
lemma natDegree_normalizedFactors_prod_eq_sum (p : Polynomial k) (hp : p ≠ 0) :
    (UniqueFactorizationMonoid.normalizedFactors p).prod.natDegree =
    ((UniqueFactorizationMonoid.normalizedFactors p).map Polynomial.natDegree).sum := by
  apply Polynomial.natDegree_multiset_prod_of_monic
  intro q hq
  exact monic_of_mem_normalizedFactors k p hq

/-- The intValuation relates to ord via exp(-ord).

Note: This is a key bridge between the valuation and divisibility views. -/
lemma intValuation_eq_exp_neg_ord (v : HeightOneSpectrum (Polynomial k))
    (p : Polynomial k) (hp : p ≠ 0) :
    v.intValuation p = WithZero.exp (-(ord k v p : ℤ)) := by
  -- The key insight: both definitions count the same thing
  -- intValuation uses Associates.count on ideals
  -- ord uses divisibility of generator
  -- These agree because v.asIdeal = span{generator(v)}
  sorry

/-- **Key Theorem**: natDegree equals sum of ord × degree over all places.

This is the algebraic foundation for degree bounds. It follows from:
1. p = leadingCoeff * ∏_v generator(v)^{ord_v(p)} (unique factorization)
2. natDegree is additive: natDegree(a*b) = natDegree(a) + natDegree(b)
3. natDegree(generator(v)) = degree(v) by definition
4. natDegree(c) = 0 for constants c ∈ k

The sum is finite because p has only finitely many irreducible factors.
-/
theorem natDegree_eq_sum_ord_mul_degree (p : Polynomial k) (hp : p ≠ 0)
    (S : Finset (HeightOneSpectrum (Polynomial k)))
    (hS : ∀ v, ord k v p ≠ 0 → v ∈ S) :
    (p.natDegree : ℤ) = ∑ v ∈ S, (ord k v p : ℤ) * (degree k v : ℤ) := by
  -- The proof uses unique factorization in k[X]
  -- p = c * ∏ gen(v)^{ord_v(p)} where c = leadingCoeff / (product of leading coeffs)
  -- Since generators are monic, c = leadingCoeff (a unit in k)
  -- natDegree(p) = natDegree(∏ gen(v)^{ord_v(p)}) = Σ ord_v(p) * natDegree(gen(v))
  sorry

/-- For a rational function f = num/denom, the intDegree bounds relate to valuations.

**Key insight**: At each place v:
- val_v(f) = exp(ord_v(denom) - ord_v(num)) where ord_v is the multiplicity
- The constraint val_v(f) ≤ exp(-D(v)) means ord_v(num) - ord_v(denom) ≥ D(v)

For polynomials p ≠ 0, natDegree(p) = Σ_v ord_v(p) * deg(v) (sum over all zeros).

With IsLinearPlaceSupport (deg(v) = 1 for all v ∈ D.support), this becomes:
- intDegree(f) = Σ (ord_v(num) - ord_v(denom))
              ≥ Σ D(v) = D.deg

**Mathematical proof outline**:
1. By unique factorization: p = u * ∏ gen_v^{ord_v(p)} where u is the leading coeff
2. natDegree(p) = Σ ord_v(p) * natDegree(gen_v) = Σ ord_v(p) * deg(v)
3. For f = num/denom: intDegree = num.natDegree - denom.natDegree
                                 = Σ ord_v(num) * deg(v) - Σ ord_v(denom) * deg(v)
4. With IsLinearPlaceSupport: deg(v) = 1 for v ∈ D.support
5. Using constraints: intDegree ≥ Σ D(v) = D.deg
-/
theorem intDegree_ge_deg_of_valuation_bounds_and_linear_support
    (D : DivisorV2 (Polynomial k)) (f : RatFunc k) (hf : f ≠ 0)
    (hf_val : ∀ v, v.valuation (RatFunc k) f ≤ WithZero.exp (-D v))
    (hdenom_only_neg : ∀ v, f.denom ∈ v.asIdeal → D v < 0)
    (hlin : ∀ v ∈ D.support, degree k v = 1) :
    f.intDegree ≥ D.deg := by
  /-
  **Blocked**: This theorem requires `natDegree_eq_sum_ord_mul_degree` which
  expresses natDegree as a sum over places. See Cycle 304 for the algebraic
  foundation that unblocks this proof.
  -/
  sorry

end PlaceDegree

end RiemannRochV2
