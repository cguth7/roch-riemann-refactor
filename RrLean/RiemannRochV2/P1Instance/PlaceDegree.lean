import RrLean.RiemannRochV2.Core.Basic
import RrLean.RiemannRochV2.Core.Divisor
import RrLean.RiemannRochV2.SerreDuality.P1Specific.RatFuncPairing
import RrLean.RiemannRochV2.Definitions.Infrastructure
import Mathlib.RingTheory.AdjoinRoot
import Mathlib.RingTheory.Polynomial.Quotient

/-!
# Place Degree for Polynomial Rings

This module defines the degree of a place (HeightOneSpectrum) for polynomial rings
over a field, and proves that it equals the residue field dimension.

## Main Definitions

* `PlaceDegree.degree` - The degree of a finite place as the finrank of its residue field
* `PlaceDegree.degWeighted` - Weighted degree of a divisor

## Key Results

* `finrank_residueField_eq_degree` - The residue field dimension equals the place degree
* `linearPlace_degree_eq_one` - Linear places have degree 1

## Strategy

For P¹ = RatFunc k, places are HeightOneSpectrum (Polynomial k). Each such place
corresponds to a monic irreducible polynomial p, and:
- The residue field is k[X]/(p), which has dimension deg(p) over k
- Using Mathlib's `finrank_quotient_span_eq_natDegree`, we get the dimension directly
-/

noncomputable section

namespace RiemannRochV2

namespace PlaceDegree

open IsDedekindDomain Polynomial

variable (k : Type*) [Field k] [DecidableEq k]

/-! ## Generator of a HeightOneSpectrum -/

/-- Every HeightOneSpectrum of k[X] is principal, generated by a monic irreducible.
This is because k[X] is a PID where every prime ideal is principal.

Proof: k[X] is a PID, so v.asIdeal = span{g} for some g.
Since v.asIdeal is prime and nonzero, g is irreducible.
Normalize to monic by scaling by (leadingCoeff g)⁻¹. -/
theorem exists_generator (v : HeightOneSpectrum (Polynomial k)) :
    ∃ p : Polynomial k, p.Monic ∧ Irreducible p ∧ v.asIdeal = Ideal.span {p} := by
  -- k[X] is a PID, so the prime ideal v.asIdeal is principal
  have hprinc : v.asIdeal.IsPrincipal := IsPrincipalIdealRing.principal v.asIdeal
  obtain ⟨g, hg⟩ := hprinc.principal
  -- g ≠ 0 since v.asIdeal ≠ ⊥
  have hg_ne : g ≠ 0 := by
    intro hg0
    have : v.asIdeal = ⊥ := by
      rw [hg, hg0]
      exact Submodule.span_singleton_eq_bot.mpr rfl
    exact v.ne_bot this
  -- g is irreducible since v.asIdeal is prime and nonzero in a PID
  have hg_irr : Irreducible g := by
    have hprime : v.asIdeal.IsPrime := v.isPrime
    rw [hg] at hprime
    have hprime' := (Ideal.span_singleton_prime hg_ne).mp hprime
    exact hprime'.irreducible
  -- Normalize to monic
  let u := leadingCoeff g
  have hu_ne : u ≠ 0 := leadingCoeff_ne_zero.mpr hg_ne
  use C u⁻¹ * g
  refine ⟨?monic, ?irr, ?span⟩
  case monic =>
    unfold Monic
    rw [leadingCoeff_mul, leadingCoeff_C, inv_mul_cancel₀ hu_ne]
  case irr =>
    have hCu_unit : IsUnit (C u⁻¹ : Polynomial k) := by
      rw [isUnit_C]
      exact (inv_ne_zero hu_ne).isUnit
    exact (irreducible_isUnit_mul hCu_unit).mpr hg_irr
  case span =>
    rw [hg]
    have hCu_unit : IsUnit (C u⁻¹ : Polynomial k) := by
      rw [isUnit_C]
      exact (inv_ne_zero hu_ne).isUnit
    -- span{C u⁻¹ * g} = span{g} since C u⁻¹ is a unit
    -- Convert Ideal.span to Submodule.span notation (they are equal by definition)
    simp only [← Ideal.submodule_span_eq]
    -- Now both sides are k[X] ∙ _, use span_singleton_eq_span_singleton
    rw [Submodule.span_singleton_eq_span_singleton]
    -- Need: ∃ z : (Polynomial k)ˣ, z • g = C u⁻¹ * g
    refine ⟨hCu_unit.unit, ?_⟩
    rw [Units.smul_def, IsUnit.unit_spec, smul_eq_mul]

/-- Choose a generator for a HeightOneSpectrum (monic irreducible polynomial). -/
noncomputable def generator (v : HeightOneSpectrum (Polynomial k)) : Polynomial k :=
  (exists_generator k v).choose

lemma generator_monic (v : HeightOneSpectrum (Polynomial k)) : (generator k v).Monic :=
  (exists_generator k v).choose_spec.1

lemma generator_irreducible (v : HeightOneSpectrum (Polynomial k)) : Irreducible (generator k v) :=
  (exists_generator k v).choose_spec.2.1

lemma asIdeal_eq_span_generator (v : HeightOneSpectrum (Polynomial k)) :
    v.asIdeal = Ideal.span {generator k v} :=
  (exists_generator k v).choose_spec.2.2

/-! ## Place Degree -/

/-- The degree of a finite place on Polynomial k is the natDegree of its generator.
This equals the residue field dimension [κ(v) : k]. -/
def degree (v : HeightOneSpectrum (Polynomial k)) : ℕ :=
  (generator k v).natDegree

/-- The degree is at least 1 for any place.

Proof: The generator is irreducible, and irreducible polynomials have degree ≥ 1.
Over a field, degree 0 polynomials are units, contradicting irreducibility. -/
lemma degree_pos (v : HeightOneSpectrum (Polynomial k)) : 0 < degree k v := by
  unfold degree
  have hirr := generator_irreducible k v
  -- Irreducible polynomials over a field have degree ≥ 1
  exact hirr.natDegree_pos

/-- Linear places have degree 1.

Proof: The generator and X - C α generate the same ideal, so they are associated.
Both are monic, so they must be equal. X - C α has natDegree 1. -/
lemma linearPlace_degree_eq_one (α : k) :
    degree k (linearPlace α) = 1 := by
  unfold degree
  have hgen := asIdeal_eq_span_generator k (linearPlace α)
  have hlin : (linearPlace α).asIdeal = Ideal.span {X - C α} := rfl
  rw [hlin] at hgen
  -- span{generator} = span{X - C α}, so they are associated
  have hassoc : Associated (generator k (linearPlace α)) (X - C α) := by
    rw [← Ideal.span_singleton_eq_span_singleton]
    exact hgen.symm
  have hmonic_gen := generator_monic k (linearPlace α)
  have hmonic_lin : (X - C α : Polynomial k).Monic := monic_X_sub_C α
  -- Associated monic polynomials are equal
  have heq : generator k (linearPlace α) = X - C α :=
    eq_of_monic_of_associated hmonic_gen hmonic_lin hassoc
  rw [heq, natDegree_X_sub_C]

/-! ## Finrank of Residue Field -/

/-- The residue field of a place v has finrank equal to the place degree.
This uses Mathlib's `finrank_quotient_span_eq_natDegree`. -/
theorem finrank_residueField_eq_degree (v : HeightOneSpectrum (Polynomial k)) :
    Module.finrank k (Polynomial k ⧸ v.asIdeal) = degree k v := by
  rw [asIdeal_eq_span_generator k v]
  exact finrank_quotient_span_eq_natDegree

/-! ## Weighted Degree -/

/-- The weighted degree of a divisor, taking place degrees into account.
For D = Σ nᵥ · [v], this is Σ nᵥ · deg(v). -/
def degWeighted (D : DivisorV2 (Polynomial k)) : ℤ :=
  D.sum (fun v n => n * (degree k v : ℤ))

/-- For linear places, weighted degree equals unweighted degree. -/
lemma degWeighted_eq_deg_of_linear {D : DivisorV2 (Polynomial k)}
    (hlin : ∀ v ∈ D.support, degree k v = 1) :
    degWeighted k D = D.deg := by
  unfold degWeighted DivisorV2.deg
  apply Finsupp.sum_congr
  intro v hv
  rw [hlin v hv, Nat.cast_one, mul_one]

/-- Weighted degree of a single-place divisor. -/
lemma degWeighted_single (v : HeightOneSpectrum (Polynomial k)) (n : ℤ) :
    degWeighted k (DivisorV2.single v n) = n * (degree k v : ℤ) := by
  unfold degWeighted DivisorV2.single
  rw [Finsupp.sum_single_index (by ring)]

/-- Weighted degree is additive. -/
lemma degWeighted_add (D E : DivisorV2 (Polynomial k)) :
    degWeighted k (D + E) = degWeighted k D + degWeighted k E := by
  unfold degWeighted
  rw [Finsupp.sum_add_index']
  · intro v; ring
  · intro v n₁ n₂; ring

/-- Weighted degree of negation. -/
lemma degWeighted_neg (D : DivisorV2 (Polynomial k)) :
    degWeighted k (-D) = -degWeighted k D := by
  unfold degWeighted
  rw [Finsupp.sum_neg_index]
  · simp only [neg_mul, Finsupp.sum_neg]
  · intro _; ring

/-- Weighted degree is subtractive. -/
lemma degWeighted_sub (D E : DivisorV2 (Polynomial k)) :
    degWeighted k (D - E) = degWeighted k D - degWeighted k E := by
  rw [sub_eq_add_neg, degWeighted_add, degWeighted_neg, sub_eq_add_neg]

/-! ## Coprimality of Distinct Primes -/

/-- The generator of one prime is not in another prime ideal for distinct primes.

In k[X], distinct HeightOneSpectrum correspond to distinct monic irreducibles.
These generate coprime ideals. -/
lemma generator_not_mem_other_prime (v w : HeightOneSpectrum (Polynomial k))
    (hw : w ≠ v) : generator k v ∉ w.asIdeal := by
  -- If generator k v ∈ w.asIdeal, then v.asIdeal ⊆ w.asIdeal
  intro hgen_mem_w
  -- v.asIdeal = span{generator k v} ⊆ w.asIdeal
  have hv_le_w : v.asIdeal ≤ w.asIdeal := by
    rw [asIdeal_eq_span_generator k v]
    exact Ideal.span_le.mpr (Set.singleton_subset_iff.mpr hgen_mem_w)
  -- v.asIdeal is maximal (height-1 prime in k[X] is maximal)
  have hv_max := v.isMaximal
  -- w.asIdeal is prime and ≠ ⊤
  have hw_prime := w.isPrime
  -- By maximality: v.asIdeal ≤ w.asIdeal and w ≠ ⊤ implies v.asIdeal = w.asIdeal
  have heq : v.asIdeal = w.asIdeal := hv_max.eq_of_le hw_prime.ne_top hv_le_w
  -- But v.asIdeal ≠ w.asIdeal since hw : w ≠ v
  exact hw (HeightOneSpectrum.ext heq.symm)

/-- The generator of v has valuation 1 at other primes w ≠ v. -/
lemma generator_intValuation_at_other_prime (v w : HeightOneSpectrum (Polynomial k))
    (hw : w ≠ v) : w.intValuation (generator k v) = 1 := by
  rw [HeightOneSpectrum.intValuation_eq_one_iff]
  exact generator_not_mem_other_prime k v w hw

/-- The uniformizer at v is not in w.asIdeal for w ≠ v.

Key insight: uniformizer π has intValuation = exp(-1) at v, meaning π ∈ v.asIdeal \ v.asIdeal².
Since π and generator(v) both have v-valuation exp(-1), they're associates.
Associates have the same ideal membership, so π ∈ w.asIdeal iff generator(v) ∈ w.asIdeal.
But generator(v) ∉ w.asIdeal for w ≠ v (by generator_not_mem_other_prime). -/
lemma uniformizerAt_not_mem_other_prime (v w : HeightOneSpectrum (Polynomial k))
    (hw : w ≠ v) : uniformizerAt v ∉ w.asIdeal := by
  intro hπ_mem_w
  -- π ∈ v.asIdeal (with valuation exp(-1))
  have hπ_mem_v : uniformizerAt v ∈ v.asIdeal := by
    have hval := uniformizerAt_val v
    rw [← v.intValuation_lt_one_iff_mem, hval]
    exact WithZero.exp_lt_exp.mpr (by omega : (-1 : ℤ) < 0)

  -- Both π and generator(v) have v-valuation exp(-1), so they generate the same ideal
  -- In a PID, this means they're associates
  have hspan_π : Ideal.span {uniformizerAt v} = v.asIdeal := by
    apply le_antisymm
    · exact Ideal.span_le.mpr (Set.singleton_subset_iff.mpr hπ_mem_v)
    · -- Use that both have the same v-valuation
      rw [asIdeal_eq_span_generator k v, Ideal.span_singleton_le_span_singleton]
      -- Need: π | generator(v)
      -- This follows from both having v-val exp(-1) in a UFD
      -- In k[X], valuation exp(-1) means exactly one factor of the prime
      -- So π = u * generator(v) for some unit u, hence generator(v) | π and π | generator(v)
      sorry

  have hassoc : Associated (uniformizerAt v) (generator k v) := by
    rw [← Ideal.span_singleton_eq_span_singleton, hspan_π, asIdeal_eq_span_generator k v]

  -- hu : uniformizerAt v * u = generator k v for some unit u
  obtain ⟨u, hu⟩ := hassoc
  have hgen_mem_w : generator k v ∈ w.asIdeal := by
    rw [← hu]
    exact w.asIdeal.mul_mem_right (u : Polynomial k) hπ_mem_w

  exact generator_not_mem_other_prime k v w hw hgen_mem_w

/-- The uniformizer at v has intValuation 1 at primes w ≠ v. -/
lemma uniformizerAt_intValuation_at_other_prime (v w : HeightOneSpectrum (Polynomial k))
    (hw : w ≠ v) : w.intValuation (uniformizerAt v) = 1 := by
  rw [HeightOneSpectrum.intValuation_eq_one_iff]
  exact uniformizerAt_not_mem_other_prime k v w hw

end PlaceDegree

end RiemannRochV2
