import RrLean.RiemannRochV2.Core.Basic
import RrLean.RiemannRochV2.Core.Divisor
import RrLean.RiemannRochV2.SerreDuality.P1Specific.RatFuncPairing
import RrLean.RiemannRochV2.Definitions.Infrastructure
import Mathlib.RingTheory.AdjoinRoot
import Mathlib.RingTheory.Polynomial.Quotient

/-!
# Place Degree for Polynomial Rings

This module defines the degree of a place (HeightOneSpectrum) for polynomial rings
over a field, and proves that it equals the residue field dimension.

## Main Definitions

* `PlaceDegree.degree` - The degree of a finite place as the finrank of its residue field
* `PlaceDegree.degWeighted` - Weighted degree of a divisor

## Key Results

* `finrank_residueField_eq_degree` - The residue field dimension equals the place degree
* `linearPlace_degree_eq_one` - Linear places have degree 1

## Strategy

For P¹ = RatFunc k, places are HeightOneSpectrum (Polynomial k). Each such place
corresponds to a monic irreducible polynomial p, and:
- The residue field is k[X]/(p), which has dimension deg(p) over k
- Using Mathlib's `finrank_quotient_span_eq_natDegree`, we get the dimension directly
-/

noncomputable section

namespace RiemannRochV2

namespace PlaceDegree

open IsDedekindDomain Polynomial

variable (k : Type*) [Field k] [DecidableEq k]

/-! ## Generator of a HeightOneSpectrum -/

/-- Every HeightOneSpectrum of k[X] is principal, generated by a monic irreducible.
This is because k[X] is a PID where every prime ideal is principal.

Proof: k[X] is a PID, so v.asIdeal = span{g} for some g.
Since v.asIdeal is prime and nonzero, g is irreducible.
Normalize to monic by scaling by (leadingCoeff g)⁻¹. -/
theorem exists_generator (v : HeightOneSpectrum (Polynomial k)) :
    ∃ p : Polynomial k, p.Monic ∧ Irreducible p ∧ v.asIdeal = Ideal.span {p} := by
  -- k[X] is a PID, so the prime ideal v.asIdeal is principal
  have hprinc : v.asIdeal.IsPrincipal := IsPrincipalIdealRing.principal v.asIdeal
  obtain ⟨g, hg⟩ := hprinc.principal
  -- g ≠ 0 since v.asIdeal ≠ ⊥
  have hg_ne : g ≠ 0 := by
    intro hg0
    have : v.asIdeal = ⊥ := by
      rw [hg, hg0]
      exact Submodule.span_singleton_eq_bot.mpr rfl
    exact v.ne_bot this
  -- g is irreducible since v.asIdeal is prime and nonzero in a PID
  have hg_irr : Irreducible g := by
    have hprime : v.asIdeal.IsPrime := v.isPrime
    rw [hg] at hprime
    have hprime' := (Ideal.span_singleton_prime hg_ne).mp hprime
    exact hprime'.irreducible
  -- Normalize to monic
  let u := leadingCoeff g
  have hu_ne : u ≠ 0 := leadingCoeff_ne_zero.mpr hg_ne
  use C u⁻¹ * g
  refine ⟨?monic, ?irr, ?span⟩
  case monic =>
    unfold Monic
    rw [leadingCoeff_mul, leadingCoeff_C, inv_mul_cancel₀ hu_ne]
  case irr =>
    have hCu_unit : IsUnit (C u⁻¹ : Polynomial k) := by
      rw [isUnit_C]
      exact (inv_ne_zero hu_ne).isUnit
    exact (irreducible_isUnit_mul hCu_unit).mpr hg_irr
  case span =>
    rw [hg]
    have hCu_unit : IsUnit (C u⁻¹ : Polynomial k) := by
      rw [isUnit_C]
      exact (inv_ne_zero hu_ne).isUnit
    -- span{C u⁻¹ * g} = span{g} since C u⁻¹ is a unit
    -- Convert Ideal.span to Submodule.span notation (they are equal by definition)
    simp only [← Ideal.submodule_span_eq]
    -- Now both sides are k[X] ∙ _, use span_singleton_eq_span_singleton
    rw [Submodule.span_singleton_eq_span_singleton]
    -- Need: ∃ z : (Polynomial k)ˣ, z • g = C u⁻¹ * g
    refine ⟨hCu_unit.unit, ?_⟩
    rw [Units.smul_def, IsUnit.unit_spec, smul_eq_mul]

/-- Choose a generator for a HeightOneSpectrum (monic irreducible polynomial). -/
noncomputable def generator (v : HeightOneSpectrum (Polynomial k)) : Polynomial k :=
  (exists_generator k v).choose

lemma generator_monic (v : HeightOneSpectrum (Polynomial k)) : (generator k v).Monic :=
  (exists_generator k v).choose_spec.1

lemma generator_irreducible (v : HeightOneSpectrum (Polynomial k)) : Irreducible (generator k v) :=
  (exists_generator k v).choose_spec.2.1

lemma asIdeal_eq_span_generator (v : HeightOneSpectrum (Polynomial k)) :
    v.asIdeal = Ideal.span {generator k v} :=
  (exists_generator k v).choose_spec.2.2

/-! ## Place Degree -/

/-- The degree of a finite place on Polynomial k is the natDegree of its generator.
This equals the residue field dimension [κ(v) : k]. -/
def degree (v : HeightOneSpectrum (Polynomial k)) : ℕ :=
  (generator k v).natDegree

/-- The degree is at least 1 for any place.

Proof: The generator is irreducible, and irreducible polynomials have degree ≥ 1.
Over a field, degree 0 polynomials are units, contradicting irreducibility. -/
lemma degree_pos (v : HeightOneSpectrum (Polynomial k)) : 0 < degree k v := by
  unfold degree
  have hirr := generator_irreducible k v
  -- Irreducible polynomials over a field have degree ≥ 1
  exact hirr.natDegree_pos

/-- Linear places have degree 1.

Proof: The generator and X - C α generate the same ideal, so they are associated.
Both are monic, so they must be equal. X - C α has natDegree 1. -/
lemma linearPlace_degree_eq_one (α : k) :
    degree k (linearPlace α) = 1 := by
  unfold degree
  have hgen := asIdeal_eq_span_generator k (linearPlace α)
  have hlin : (linearPlace α).asIdeal = Ideal.span {X - C α} := rfl
  rw [hlin] at hgen
  -- span{generator} = span{X - C α}, so they are associated
  have hassoc : Associated (generator k (linearPlace α)) (X - C α) := by
    rw [← Ideal.span_singleton_eq_span_singleton]
    exact hgen.symm
  have hmonic_gen := generator_monic k (linearPlace α)
  have hmonic_lin : (X - C α : Polynomial k).Monic := monic_X_sub_C α
  -- Associated monic polynomials are equal
  have heq : generator k (linearPlace α) = X - C α :=
    eq_of_monic_of_associated hmonic_gen hmonic_lin hassoc
  rw [heq, natDegree_X_sub_C]

/-! ## Finrank of Residue Field -/

/-- The residue field of a place v has finrank equal to the place degree.
This uses Mathlib's `finrank_quotient_span_eq_natDegree`. -/
theorem finrank_residueField_eq_degree (v : HeightOneSpectrum (Polynomial k)) :
    Module.finrank k (Polynomial k ⧸ v.asIdeal) = degree k v := by
  rw [asIdeal_eq_span_generator k v]
  exact finrank_quotient_span_eq_natDegree

/-! ## Weighted Degree -/

/-- The weighted degree of a divisor, taking place degrees into account.
For D = Σ nᵥ · [v], this is Σ nᵥ · deg(v). -/
def degWeighted (D : DivisorV2 (Polynomial k)) : ℤ :=
  D.sum (fun v n => n * (degree k v : ℤ))

/-- For linear places, weighted degree equals unweighted degree. -/
lemma degWeighted_eq_deg_of_linear {D : DivisorV2 (Polynomial k)}
    (hlin : ∀ v ∈ D.support, degree k v = 1) :
    degWeighted k D = D.deg := by
  unfold degWeighted DivisorV2.deg
  apply Finsupp.sum_congr
  intro v hv
  rw [hlin v hv, Nat.cast_one, mul_one]

/-- Weighted degree of a single-place divisor. -/
lemma degWeighted_single (v : HeightOneSpectrum (Polynomial k)) (n : ℤ) :
    degWeighted k (DivisorV2.single v n) = n * (degree k v : ℤ) := by
  unfold degWeighted DivisorV2.single
  rw [Finsupp.sum_single_index (by ring)]

/-- Weighted degree is additive. -/
lemma degWeighted_add (D E : DivisorV2 (Polynomial k)) :
    degWeighted k (D + E) = degWeighted k D + degWeighted k E := by
  unfold degWeighted
  rw [Finsupp.sum_add_index']
  · intro v; ring
  · intro v n₁ n₂; ring

/-- Weighted degree of negation. -/
lemma degWeighted_neg (D : DivisorV2 (Polynomial k)) :
    degWeighted k (-D) = -degWeighted k D := by
  unfold degWeighted
  rw [Finsupp.sum_neg_index]
  · simp only [neg_mul, Finsupp.sum_neg]
  · intro _; ring

/-- Weighted degree is subtractive. -/
lemma degWeighted_sub (D E : DivisorV2 (Polynomial k)) :
    degWeighted k (D - E) = degWeighted k D - degWeighted k E := by
  rw [sub_eq_add_neg, degWeighted_add, degWeighted_neg, sub_eq_add_neg]

/-! ## Coprimality of Distinct Primes -/

/-- The generator of one prime is not in another prime ideal for distinct primes.

In k[X], distinct HeightOneSpectrum correspond to distinct monic irreducibles.
These generate coprime ideals. -/
lemma generator_not_mem_other_prime (v w : HeightOneSpectrum (Polynomial k))
    (hw : w ≠ v) : generator k v ∉ w.asIdeal := by
  -- If generator k v ∈ w.asIdeal, then v.asIdeal ⊆ w.asIdeal
  intro hgen_mem_w
  -- v.asIdeal = span{generator k v} ⊆ w.asIdeal
  have hv_le_w : v.asIdeal ≤ w.asIdeal := by
    rw [asIdeal_eq_span_generator k v]
    exact Ideal.span_le.mpr (Set.singleton_subset_iff.mpr hgen_mem_w)
  -- v.asIdeal is maximal (height-1 prime in k[X] is maximal)
  have hv_max := v.isMaximal
  -- w.asIdeal is prime and ≠ ⊤
  have hw_prime := w.isPrime
  -- By maximality: v.asIdeal ≤ w.asIdeal and w ≠ ⊤ implies v.asIdeal = w.asIdeal
  have heq : v.asIdeal = w.asIdeal := hv_max.eq_of_le hw_prime.ne_top hv_le_w
  -- But v.asIdeal ≠ w.asIdeal since hw : w ≠ v
  exact hw (HeightOneSpectrum.ext heq.symm)

/-- The generator of v has valuation 1 at other primes w ≠ v. -/
lemma generator_intValuation_at_other_prime (v w : HeightOneSpectrum (Polynomial k))
    (hw : w ≠ v) : w.intValuation (generator k v) = 1 := by
  rw [HeightOneSpectrum.intValuation_eq_one_iff]
  exact generator_not_mem_other_prime k v w hw

/-- The generator of v has v-adic valuation exp(-1).

This is the key lemma that connects generators to uniformizers.
Since v.asIdeal = span{generator}, and intValuation_singleton says
the valuation of a generator of the ideal is exp(-1), we're done. -/
lemma generator_intValuation_at_self (v : HeightOneSpectrum (Polynomial k)) :
    v.intValuation (generator k v) = WithZero.exp (-1 : ℤ) := by
  have hgen_ne : generator k v ≠ 0 := (generator_irreducible k v).ne_zero
  have hspan := asIdeal_eq_span_generator k v
  exact v.intValuation_singleton hgen_ne hspan

/-! ## Uniformizer-Generator Relationship

The abstract `uniformizerAt v` from Infrastructure.lean is defined as ANY element with
v.intValuation = exp(-1). In k[X], this could be `generator(v) * w` for some polynomial w
coprime to gen. The following lemmas establish the relationship needed for the
evaluation map surjectivity proof. -/

/-- The uniformizer is in v.asIdeal (has valuation < 1). -/
lemma uniformizerAt_mem_asIdeal (v : HeightOneSpectrum (Polynomial k)) :
    uniformizerAt v ∈ v.asIdeal := by
  rw [← v.intValuation_lt_one_iff_mem, uniformizerAt_val]
  -- exp(-1) < exp(0) = 1
  exact WithZero.exp_lt_exp.mpr (by norm_num : (-1 : ℤ) < 0)

/-- The uniformizer is not in v.asIdeal² (has valuation exactly exp(-1), not exp(-2)). -/
lemma uniformizerAt_not_mem_asIdeal_sq (v : HeightOneSpectrum (Polynomial k)) :
    uniformizerAt v ∉ v.asIdeal ^ 2 := by
  intro h
  have hval := uniformizerAt_val v
  -- If π ∈ v.asIdeal², then v(π) ≤ exp(-2)
  have hval_le : v.intValuation (uniformizerAt v) ≤ WithZero.exp (-2 : ℤ) :=
    (v.intValuation_le_pow_iff_mem (uniformizerAt v) 2).mpr h
  rw [hval] at hval_le
  -- exp(-1) ≤ exp(-2) is false since -1 > -2
  have hcontra : (-1 : ℤ) ≤ -2 := WithZero.exp_le_exp.mp hval_le
  omega

/-- The generator divides the uniformizer in k[X]. -/
lemma generator_dvd_uniformizerAt (v : HeightOneSpectrum (Polynomial k)) :
    generator k v ∣ uniformizerAt v := by
  have hmem := uniformizerAt_mem_asIdeal k v
  rw [asIdeal_eq_span_generator k v, Ideal.mem_span_singleton] at hmem
  exact hmem

/-- The quotient w = uniformizerAt / generator (using polynomial division). -/
noncomputable def uniformizerQuotient (v : HeightOneSpectrum (Polynomial k)) : Polynomial k :=
  uniformizerAt v /ₘ generator k v

/-- Key: uniformizerAt = generator * uniformizerQuotient. -/
lemma uniformizerAt_eq_generator_mul_quotient (v : HeightOneSpectrum (Polynomial k)) :
    uniformizerAt v = generator k v * uniformizerQuotient k v := by
  have hmonic := generator_monic k v
  have hdvd := generator_dvd_uniformizerAt k v
  rw [uniformizerQuotient]
  -- For monic divisor, p %ₘ d + d * (p /ₘ d) = p, and when d | p, p %ₘ d = 0
  have hmod_zero : uniformizerAt v %ₘ generator k v = 0 := by
    rw [Polynomial.modByMonic_eq_zero_iff_dvd hmonic]
    exact hdvd
  have hdiv := Polynomial.modByMonic_add_div (uniformizerAt v) hmonic
  -- hdiv : uniformizerAt v %ₘ gen + gen * (uniformizerAt v /ₘ gen) = uniformizerAt v
  rw [hmod_zero, zero_add] at hdiv
  exact hdiv.symm

/-- The quotient w is not in v.asIdeal (equivalently, gcd(w, gen) = 1). -/
lemma uniformizerQuotient_not_mem_asIdeal (v : HeightOneSpectrum (Polynomial k)) :
    uniformizerQuotient k v ∉ v.asIdeal := by
  intro hw_mem
  apply uniformizerAt_not_mem_asIdeal_sq k v
  rw [uniformizerAt_eq_generator_mul_quotient k v]
  -- gen * w ∈ v.asIdeal² when w ∈ v.asIdeal
  rw [pow_two]
  apply Ideal.mul_mem_mul
  · rw [asIdeal_eq_span_generator k v]
    exact Ideal.mem_span_singleton_self _
  · exact hw_mem

/-- The quotient w is nonzero. -/
lemma uniformizerQuotient_ne_zero (v : HeightOneSpectrum (Polynomial k)) :
    uniformizerQuotient k v ≠ 0 := by
  intro hw_zero
  have heq := uniformizerAt_eq_generator_mul_quotient k v
  rw [hw_zero, mul_zero] at heq
  exact uniformizerAt_ne_zero v heq

/-- In K = RatFunc k, uniformizerAt / generator = uniformizerQuotient. -/
lemma uniformizerAt_div_generator_eq_quotient (v : HeightOneSpectrum (Polynomial k)) :
    algebraMap (Polynomial k) (RatFunc k) (uniformizerAt v) /
    algebraMap (Polynomial k) (RatFunc k) (generator k v) =
    algebraMap (Polynomial k) (RatFunc k) (uniformizerQuotient k v) := by
  have hgen_ne : (generator k v) ≠ 0 := (generator_irreducible k v).ne_zero
  have hgen_K_ne : algebraMap (Polynomial k) (RatFunc k) (generator k v) ≠ 0 :=
    RatFunc.algebraMap_ne_zero hgen_ne
  rw [uniformizerAt_eq_generator_mul_quotient k v, map_mul]
  field_simp

/-- The residue of uniformizerQuotient in κ(v) is nonzero (hence invertible). -/
lemma uniformizerQuotient_residue_ne_zero (v : HeightOneSpectrum (Polynomial k)) :
    Ideal.Quotient.mk v.asIdeal (uniformizerQuotient k v) ≠ 0 := by
  rw [ne_eq, Ideal.Quotient.eq_zero_iff_mem]
  exact uniformizerQuotient_not_mem_asIdeal k v

end PlaceDegree

end RiemannRochV2
