{
  "active_edge": "Define ℓ(D) = finrank k L(D)",
  "candidates": [
    {
      "name": "Divisor α",
      "status": "PROVED",
      "statement": "abbrev Divisor (α : Type*) := α →₀ ℤ",
      "approach": "Type alias for Finsupp",
      "cycle": 4
    },
    {
      "name": "Divisor.deg",
      "status": "PROVED",
      "statement": "def deg (D : Divisor α) : ℤ := D.sum (fun _ n => n)",
      "approach": "Sum of coefficients",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_add",
      "status": "PROVED",
      "statement": "deg (D + E) = deg D + deg E",
      "approach": "Via Finsupp.sum_add_index'",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_zero",
      "status": "PROVED",
      "statement": "deg 0 = 0",
      "approach": "Via Finsupp.sum_zero_index",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_neg",
      "status": "PROVED",
      "statement": "deg (-D) = -deg D",
      "approach": "Derived from deg_add + omega",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_sub",
      "status": "PROVED",
      "statement": "deg (D - E) = deg D - deg E",
      "approach": "Derived from deg_add + deg_neg",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_single",
      "status": "PROVED",
      "statement": "deg (single p n) = n",
      "approach": "Via Finsupp.sum_single_index",
      "cycle": 4
    },
    {
      "name": "Divisor.Effective",
      "status": "PROVED",
      "statement": "def Effective (D : Divisor α) : Prop := 0 ≤ D",
      "approach": "Uses mathlib's Finsupp pointwise order",
      "cycle": 5
    },
    {
      "name": "Divisor.Effective_iff",
      "status": "PROVED",
      "statement": "Effective D ↔ ∀ p, 0 ≤ D p",
      "approach": "Definitional equality",
      "cycle": 5
    },
    {
      "name": "Divisor.Effective_zero",
      "status": "PROVED",
      "statement": "Effective 0",
      "approach": "le_refl",
      "cycle": 5
    },
    {
      "name": "Divisor.Effective_add",
      "status": "PROVED",
      "statement": "Effective D → Effective E → Effective (D + E)",
      "approach": "Pointwise omega",
      "cycle": 5
    },
    {
      "name": "Divisor.Effective_single",
      "status": "PROVED",
      "statement": "0 ≤ n → Effective (single p n)",
      "approach": "Case split on equality",
      "cycle": 5
    },
    {
      "name": "FunctionFieldData",
      "status": "DEFINED",
      "statement": "structure FunctionFieldData (α : Type*) with K, div, div_mul, div_one, div_inv, deg_div",
      "approach": "Axiomatizes function field with principal divisor map",
      "cycle": 5
    },
    {
      "name": "FunctionFieldData.div_zero",
      "status": "PROVED",
      "statement": "data.div 0 = 0",
      "approach": "From div_mul 0 0, algebraic manipulation",
      "cycle": 5
    },
    {
      "name": "RRSpace",
      "status": "DEFINED",
      "statement": "def RRSpace (data : FunctionFieldData α) (D : Divisor α) : Set data.K := { f | f = 0 ∨ Effective (data.div f + D) }",
      "approach": "Riemann-Roch space L(D)",
      "cycle": 5
    },
    {
      "name": "RRSpace.zero_mem",
      "status": "PROVED",
      "statement": "0 ∈ RRSpace data D",
      "approach": "Or.inl rfl",
      "cycle": 5
    },
    {
      "name": "RRSpace.mono",
      "status": "PROVED",
      "statement": "D ≤ E → RRSpace data D ⊆ RRSpace data E",
      "approach": "Pointwise comparison with omega",
      "cycle": 5
    },
    {
      "name": "FunctionFieldData.div_add",
      "status": "AXIOM",
      "statement": "∀ f g, div f ⊓ div g ≤ div (f + g)",
      "approach": "Strong triangle inequality - structure field",
      "cycle": 6
    },
    {
      "name": "FunctionFieldData.div_algebraMap",
      "status": "AXIOM",
      "statement": "∀ c : k, div (algebraMap k K c) = 0",
      "approach": "Constants have zero divisor - structure field",
      "cycle": 6
    },
    {
      "name": "RRSpace.add_mem'",
      "status": "PROVED",
      "statement": "f ∈ L(D) → g ∈ L(D) → f + g ∈ L(D)",
      "approach": "Using div_add (strong triangle inequality)",
      "cycle": 6
    },
    {
      "name": "RRSpace.smul_mem'",
      "status": "PROVED",
      "statement": "c : k → f ∈ L(D) → c • f ∈ L(D)",
      "approach": "Using div_mul + div_algebraMap",
      "cycle": 6
    },
    {
      "name": "RRSpace (Submodule)",
      "status": "DEFINED",
      "statement": "def RRSpace (data : FunctionFieldData α k) (D : Divisor α) : Submodule k data.K",
      "approach": "Full k-submodule structure with zero_mem', add_mem', smul_mem'",
      "cycle": 6
    },
    {
      "name": "RRDataWithEuler.riemannRoch",
      "status": "DERIVED_FROM_ASSUMPTIONS",
      "statement": "∀ D, ℓ(D) - ℓ(K-D) = deg(D) + 1 - g",
      "approach": "Algebraic derivation from structure fields",
      "assumptions": [
        "serreDuality : ∀ D, ell (K - D) = h1 D",
        "eulerChar_def : ∀ D, eulerChar D = ell D - h1 D",
        "eulerChar_formula : ∀ D, eulerChar D = deg D + 1 - genus"
      ],
      "note": "eulerChar_formula IS Riemann-Roch; derivation is circular",
      "cycle": 3
    },
    {
      "name": "ell",
      "status": "DEFINED",
      "statement": "def ell (data : FunctionFieldData α k) (D : Divisor α) := Module.finrank k (RRSpace data D)",
      "approach": "Semantic dimension using mathlib's finrank",
      "cycle": 7
    },
    {
      "name": "RRSpace.le_of_divisor_le",
      "status": "PROVED",
      "statement": "D ≤ E → RRSpace data D ≤ RRSpace data E",
      "approach": "SetLike.coe_subset_coe + mono",
      "cycle": 7
    },
    {
      "name": "RRSpace.one_mem_of_effective",
      "status": "PROVED",
      "statement": "Effective D → 1 ∈ RRSpace data D",
      "approach": "div 1 = 0, so 0 + D = D ≥ 0",
      "cycle": 7
    },
    {
      "name": "RRSpace.algebraMap_mem_zero",
      "status": "PROVED",
      "statement": "∀ c : k, algebraMap k K c ∈ RRSpace data 0",
      "approach": "div_algebraMap gives div c = 0",
      "cycle": 7
    },
    {
      "name": "RRSpace.algebraMap_mem_of_effective",
      "status": "PROVED",
      "statement": "Effective D → ∀ c : k, algebraMap k K c ∈ RRSpace data D",
      "approach": "div_algebraMap + effective D",
      "cycle": 7
    },
    {
      "name": "ell.mono",
      "status": "PROVED",
      "statement": "[Module.Finite k (RRSpace data E)] → D ≤ E → ell data D ≤ ell data E",
      "approach": "Submodule.finrank_mono + le_of_divisor_le",
      "cycle": 7
    },
    {
      "name": "ell.pos_of_effective",
      "status": "PROVED",
      "statement": "[Module.Finite k (RRSpace data D)] → Effective D → 1 ≤ ell data D",
      "approach": "L(D) contains 1 ≠ 0, so nontrivial",
      "cycle": 7
    },
    {
      "name": "ell.zero_pos",
      "status": "PROVED",
      "statement": "[Module.Finite k (RRSpace data 0)] → 1 ≤ ell data 0",
      "approach": "pos_of_effective + Effective_zero",
      "cycle": 7
    },
    {
      "name": "ell.mono_unconditional",
      "status": "PROVED",
      "statement": "[∀ D, Module.Finite k (RRSpace data D)] → D ≤ E → ell data D ≤ ell data E",
      "approach": "haveI from typeclass, apply ell.mono",
      "cycle": 8
    },
    {
      "name": "ell.pos_of_effective_unconditional",
      "status": "PROVED",
      "statement": "[∀ D, Module.Finite k (RRSpace data D)] → Effective D → 1 ≤ ell data D",
      "approach": "haveI from typeclass, apply ell.pos_of_effective",
      "cycle": 8
    },
    {
      "name": "ell.ge_zero_of_effective",
      "status": "PROVED",
      "statement": "[∀ D, Module.Finite k (RRSpace data D)] → Effective D → ell data 0 ≤ ell data D",
      "approach": "Via mono_unconditional with Effective ≤ relation",
      "cycle": 8
    },
    {
      "name": "ell.mono_of_effective",
      "status": "PROVED",
      "statement": "[∀ D, Module.Finite k (RRSpace data D)] → Effective D → Effective E → D ≤ E → ell data D ≤ ell data E",
      "approach": "Direct application of mono_unconditional",
      "cycle": 8
    },
    {
      "name": "ell.add_effective_le",
      "status": "PROVED",
      "statement": "[∀ D, Module.Finite k (RRSpace data D)] → Effective D → Effective E → ell data D ≤ ell data (D + E)",
      "approach": "D ≤ D + E when E effective, then mono_unconditional",
      "cycle": 8
    },
    {
      "name": "ell.zero_pos_unconditional",
      "status": "PROVED",
      "statement": "[∀ D, Module.Finite k (RRSpace data D)] → [Nontrivial k] → 1 ≤ ell data 0",
      "approach": "haveI from typeclass, apply ell.zero_pos",
      "cycle": 8
    },
    {
      "name": "RRSpace.nontrivial_of_effective",
      "status": "PROVED",
      "statement": "Effective D → Nontrivial (RRSpace data D)",
      "approach": "1 ∈ L(D) for effective D gives distinct elements",
      "cycle": 8
    },
    {
      "name": "ell.diff_le_deg_diff",
      "status": "PROVED",
      "statement": "[∀ D, Module.Finite k (RRSpace data D)] → Effective D → D ≤ E → (ell data D : ℤ) ≤ (ell data E : ℤ)",
      "approach": "Int.ofNat_le + mono_unconditional",
      "cycle": 8
    }
  ],
  "blockers": [
    "mathlib lacks: line bundles, sheaf cohomology H⁰/H¹, genus for schemes",
    "Cannot yet instantiate RRData.Div with Divisor α (needs point type from curve)",
    "RRData.deg is abstract; not yet connected to Divisor.deg",
    "Need single-point dimension bound: ell(D + single p 1) ≤ ell(D) + 1"
  ],
  "resolved_blockers": [
    "PIVOT Cycle 2: defined RRData structure (elaborates)",
    "PIVOT Cycle 3: extended to RRDataWithEuler (RR derivable from fields)",
    "CYCLE 4: Defined Divisor α := α →₀ ℤ, proved deg_add/deg_zero/deg_neg/deg_sub/deg_single",
    "CYCLE 5: Defined Effective, FunctionFieldData, RRSpace L(D)",
    "CYCLE 6: L(D) is k-Submodule - added div_add, div_algebraMap, proved add_mem'/smul_mem'",
    "CYCLE 7: ell(D) = finrank k L(D), proved mono/pos_of_effective/zero_pos",
    "CYCLE 8: Finite-dimensionality via typeclass [∀ D, Module.Finite k (RRSpace data D)], all 8 lemmas PROVED"
  ],
  "next_action": "Cycle 9: Establish single-point dimension bound for Riemann inequality"
}
