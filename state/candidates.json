{
  "active_edge": "Complete RRModuleV2_real submodule axioms (add_mem, smul_mem)",
  "candidates": [
    {
      "name": "Divisor α",
      "status": "PROVED",
      "statement": "abbrev Divisor (α : Type*) := α →₀ ℤ",
      "approach": "Type alias for Finsupp",
      "cycle": 4
    },
    {
      "name": "Divisor.deg",
      "status": "PROVED",
      "statement": "def deg (D : Divisor α) : ℤ := D.sum (fun _ n => n)",
      "approach": "Sum of coefficients",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_add",
      "status": "PROVED",
      "statement": "deg (D + E) = deg D + deg E",
      "approach": "Via Finsupp.sum_add_index'",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_zero",
      "status": "PROVED",
      "statement": "deg 0 = 0",
      "approach": "Via Finsupp.sum_zero_index",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_neg",
      "status": "PROVED",
      "statement": "deg (-D) = -deg D",
      "approach": "Derived from deg_add + omega",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_sub",
      "status": "PROVED",
      "statement": "deg (D - E) = deg D - deg E",
      "approach": "Derived from deg_add + deg_neg",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_single",
      "status": "PROVED",
      "statement": "deg (single p n) = n",
      "approach": "Via Finsupp.sum_single_index",
      "cycle": 4
    },
    {
      "name": "Divisor.Effective",
      "status": "PROVED",
      "statement": "def Effective (D : Divisor α) : Prop := 0 ≤ D",
      "approach": "Uses mathlib's Finsupp pointwise order",
      "cycle": 5
    },
    {
      "name": "FunctionFieldData",
      "status": "DEFINED",
      "statement": "structure FunctionFieldData (α : Type*) with K, div, div_mul, div_one, div_inv, deg_div",
      "approach": "Axiomatizes function field with principal divisor map",
      "cycle": 5
    },
    {
      "name": "RRSpace (Submodule)",
      "status": "DEFINED",
      "statement": "def RRSpace (data : FunctionFieldData α k) (D : Divisor α) : Submodule k data.K",
      "approach": "Full k-submodule structure with zero_mem', add_mem', smul_mem'",
      "cycle": 6
    },
    {
      "name": "ell",
      "status": "DEFINED",
      "statement": "def ell (data : FunctionFieldData α k) (D : Divisor α) := Module.finrank k (RRSpace data D)",
      "approach": "Semantic dimension using mathlib's finrank",
      "cycle": 7
    },
    {
      "name": "FunctionFieldDataWithBound",
      "status": "DEFINED",
      "statement": "structure extending FunctionFieldData with single_point_bound : ∀ D p, ell (D + p) ≤ ell D + 1",
      "approach": "Axiomatize single-point dimension bound",
      "cycle": 10
    },
    {
      "name": "ell.le_deg_add_ell_zero_from_bound",
      "status": "PROVED",
      "statement": "Effective D → (ell data D : ℤ) ≤ deg D + ell data 0",
      "approach": "RIEMANN INEQUALITY - degree induction",
      "cycle": 11
    },
    {
      "name": "FunctionFieldDataWithRR",
      "status": "DEFINED",
      "statement": "structure extending FunctionFieldDataWithBound with genus, K_div, deg_K, rr_axiom",
      "approach": "Axiomatize full Riemann-Roch as structure fields",
      "cycle": 12
    },
    {
      "name": "FunctionFieldDataWithRR.riemannRoch_eq",
      "status": "PROVED",
      "statement": "ℓ(D) - ℓ(K-D) = deg D + 1 - g",
      "approach": "Direct application of rr_axiom",
      "cycle": 12
    },
    {
      "name": "FunctionFieldDataWithRR.ell_K",
      "status": "PROVED",
      "statement": "ℓ(K) = g",
      "approach": "Apply RR to D = K, use ℓ(0) = 1 and deg(K) = 2g-2",
      "cycle": 12
    },
    {
      "name": "FunctionFieldDataWithRR.ell_K_sub_D_eq_zero_of_deg_gt",
      "status": "PROVED",
      "statement": "deg D > 2g - 2 → ℓ(K-D) = 0",
      "approach": "Vanishing via deg_div semantic content",
      "cycle": 12
    },
    {
      "name": "FunctionFieldDataWithMul.clifford_bound'",
      "status": "PROVED",
      "statement": "ℓ(D) ≥ 2 → ℓ(K-D) ≥ 2 → 2·ℓ(D) ≤ deg D + 2",
      "approach": "Clifford's theorem via multiplication axiom",
      "cycle": 16
    }
  ],
  "cycle_18_candidates": [
    {
      "name": "import AdicValuation",
      "status": "OK",
      "statement": "import Mathlib.RingTheory.DedekindDomain.AdicValuation",
      "approach": "Brings in HeightOneSpectrum.valuation API",
      "score": 5,
      "cycle": 18
    },
    {
      "name": "satisfiesValuationCondition",
      "status": "DEFINED",
      "statement": "def satisfiesValuationCondition (D) (f) := f = 0 ∨ ∀ v, v.valuation K f ≥ exp(-D v)",
      "approach": "Real membership condition for L(D) using valuations",
      "score": 5,
      "cycle": 18
    },
    {
      "name": "RRModuleV2_real",
      "status": "SORRY (2)",
      "statement": "def RRModuleV2_real (D) : Submodule R K (with real carrier)",
      "approach": "L(D) as submodule with valuation-based membership",
      "score": 3,
      "blocker": "add_mem' and smul_mem' need ordered monoid reasoning",
      "cycle": 18
    },
    {
      "name": "RRModuleV2_real_zero_mem",
      "status": "PROVED",
      "statement": "0 ∈ (RRModuleV2_real R K D).carrier",
      "approach": "Trivial: Or.inl rfl",
      "score": 5,
      "cycle": 18
    },
    {
      "name": "RRModuleV2_mono_inclusion",
      "status": "PROVED",
      "statement": "D ≤ E → RRModuleV2_real R K D ≤ RRModuleV2_real R K E",
      "approach": "Uses WithZero.exp_le_exp for monotonicity",
      "score": 5,
      "cycle": 18
    }
  ],
  "cycle_17_candidates": [
    {
      "name": "DivisorV2",
      "status": "DEFINED",
      "statement": "abbrev DivisorV2 := HeightOneSpectrum R →₀ ℤ",
      "approach": "Constructive divisor using mathlib's HeightOneSpectrum",
      "score": 5,
      "cycle": 17
    },
    {
      "name": "DivisorV2.deg",
      "status": "PROVED",
      "statement": "def deg (D : DivisorV2 R) : ℤ := D.sum (fun _ n => n)",
      "approach": "Sum of coefficients (identical to v1)",
      "score": 5,
      "cycle": 17
    },
    {
      "name": "DivisorV2.deg_add, deg_zero, deg_neg, deg_single",
      "status": "PROVED",
      "statement": "Degree additivity lemmas",
      "approach": "Via Finsupp lemmas",
      "score": 5,
      "cycle": 17
    },
    {
      "name": "localization_at_prime_is_dvr",
      "status": "PROVED",
      "statement": "instance IsDiscreteValuationRing (Localization.AtPrime v.asIdeal)",
      "approach": "Uses mathlib IsLocalization.AtPrime.isDiscreteValuationRing_of_dedekind_domain",
      "score": 5,
      "cycle": 17
    },
    {
      "name": "RRModuleV2",
      "status": "PLACEHOLDER",
      "statement": "def RRModuleV2 (D : DivisorV2 R) : Submodule R K",
      "approach": "PLACEHOLDER - needs real valuation-based membership condition",
      "score": 2,
      "blocker": "Requires ord_v extraction from DVR localization",
      "cycle": 17
    },
    {
      "name": "ellV2",
      "status": "DEFINED",
      "statement": "def ellV2 (D : DivisorV2 R) : ℕ := (Module.length R (RRModuleV2 R K D)).toNat",
      "approach": "Module.length instead of finrank (additive in exact sequences)",
      "score": 3,
      "cycle": 17
    },
    {
      "name": "ellV2_mono",
      "status": "SORRY",
      "statement": "D ≤ E → ellV2 R K D ≤ ellV2 R K E",
      "approach": "Strategy: exact sequence + Module.length_eq_add_of_exact",
      "blocker": "Blocked on real RRModuleV2 definition",
      "score": 2,
      "cycle": 17
    },
    {
      "name": "divisorToFractionalIdeal",
      "status": "PLACEHOLDER",
      "statement": "def divisorToFractionalIdeal (D : DivisorV2 R) : FractionalIdeal (nonZeroDivisors R) K",
      "approach": "Returns 1 (placeholder) - needs ∏ v^{D(v)} construction",
      "score": 2,
      "cycle": 17
    },
    {
      "name": "riemann_inequality",
      "status": "SORRY",
      "statement": "(ellV2 R K D : ℤ) ≤ D.deg + 1",
      "approach": "Strategy: induction on deg(D) using single-point bound",
      "blocker": "Blocked on ellV2_mono and real RRModuleV2",
      "score": 1,
      "cycle": 17
    }
  ],
  "blockers": [
    "mathlib lacks: line bundles, sheaf cohomology H⁰/H¹, genus for schemes",
    "Base RRData.riemannRoch has no proof path without additional structure axioms",
    "RRModuleV2_real.add_mem' needs ultrametric/ordered monoid reasoning",
    "RRModuleV2_real.smul_mem' needs ordered monoid reasoning for WithZero ℤᵐ⁰"
  ],
  "resolved_blockers": [
    "CYCLE 4-6: Divisor foundations, FunctionFieldData, RRSpace as k-Submodule",
    "CYCLE 7-8: ell(D) = finrank, finite-dimensionality via typeclass",
    "CYCLE 9: Quotient infrastructure for dimension bounds",
    "CYCLE 10: FunctionFieldDataWithBound axiom extension",
    "CYCLE 11: Riemann inequality PROVED via degree induction",
    "CYCLE 12: Full FunctionFieldDataWithRR structure, 7 lemmas PROVED",
    "CYCLE 13: Cleanup - removed 4 superseded sorries",
    "CYCLE 14: Genus 0 special cases - 7 lemmas PROVED",
    "CYCLE 15: Genus 1 / Elliptic curves - 6 lemmas PROVED",
    "CYCLE 16: Clifford's theorem PROVED via multiplication axiom",
    "CYCLE 17: RR_v2.lean created - Dedekind domain foundations",
    "CYCLE 18: Valuation-based L(D) defined, RRModuleV2_mono_inclusion PROVED"
  ],
  "next_action": "Cycle 19: Complete RRModuleV2_real submodule axioms using ordered monoid lemmas"
}
