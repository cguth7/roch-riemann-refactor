{
  "active_edge": "Define ℓ(D) = finrank k L(D)",
  "candidates": [
    {
      "name": "Divisor α",
      "status": "PROVED",
      "statement": "abbrev Divisor (α : Type*) := α →₀ ℤ",
      "approach": "Type alias for Finsupp",
      "cycle": 4
    },
    {
      "name": "Divisor.deg",
      "status": "PROVED",
      "statement": "def deg (D : Divisor α) : ℤ := D.sum (fun _ n => n)",
      "approach": "Sum of coefficients",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_add",
      "status": "PROVED",
      "statement": "deg (D + E) = deg D + deg E",
      "approach": "Via Finsupp.sum_add_index'",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_zero",
      "status": "PROVED",
      "statement": "deg 0 = 0",
      "approach": "Via Finsupp.sum_zero_index",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_neg",
      "status": "PROVED",
      "statement": "deg (-D) = -deg D",
      "approach": "Derived from deg_add + omega",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_sub",
      "status": "PROVED",
      "statement": "deg (D - E) = deg D - deg E",
      "approach": "Derived from deg_add + deg_neg",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_single",
      "status": "PROVED",
      "statement": "deg (single p n) = n",
      "approach": "Via Finsupp.sum_single_index",
      "cycle": 4
    },
    {
      "name": "Divisor.Effective",
      "status": "PROVED",
      "statement": "def Effective (D : Divisor α) : Prop := 0 ≤ D",
      "approach": "Uses mathlib's Finsupp pointwise order",
      "cycle": 5
    },
    {
      "name": "Divisor.Effective_iff",
      "status": "PROVED",
      "statement": "Effective D ↔ ∀ p, 0 ≤ D p",
      "approach": "Definitional equality",
      "cycle": 5
    },
    {
      "name": "Divisor.Effective_zero",
      "status": "PROVED",
      "statement": "Effective 0",
      "approach": "le_refl",
      "cycle": 5
    },
    {
      "name": "Divisor.Effective_add",
      "status": "PROVED",
      "statement": "Effective D → Effective E → Effective (D + E)",
      "approach": "Pointwise omega",
      "cycle": 5
    },
    {
      "name": "Divisor.Effective_single",
      "status": "PROVED",
      "statement": "0 ≤ n → Effective (single p n)",
      "approach": "Case split on equality",
      "cycle": 5
    },
    {
      "name": "FunctionFieldData",
      "status": "DEFINED",
      "statement": "structure FunctionFieldData (α : Type*) with K, div, div_mul, div_one, div_inv, deg_div",
      "approach": "Axiomatizes function field with principal divisor map",
      "cycle": 5
    },
    {
      "name": "FunctionFieldData.div_zero",
      "status": "PROVED",
      "statement": "data.div 0 = 0",
      "approach": "From div_mul 0 0, algebraic manipulation",
      "cycle": 5
    },
    {
      "name": "RRSpace",
      "status": "DEFINED",
      "statement": "def RRSpace (data : FunctionFieldData α) (D : Divisor α) : Set data.K := { f | f = 0 ∨ Effective (data.div f + D) }",
      "approach": "Riemann-Roch space L(D)",
      "cycle": 5
    },
    {
      "name": "RRSpace.zero_mem",
      "status": "PROVED",
      "statement": "0 ∈ RRSpace data D",
      "approach": "Or.inl rfl",
      "cycle": 5
    },
    {
      "name": "RRSpace.mono",
      "status": "PROVED",
      "statement": "D ≤ E → RRSpace data D ⊆ RRSpace data E",
      "approach": "Pointwise comparison with omega",
      "cycle": 5
    },
    {
      "name": "FunctionFieldData.div_add",
      "status": "AXIOM",
      "statement": "∀ f g, div f ⊓ div g ≤ div (f + g)",
      "approach": "Strong triangle inequality - structure field",
      "cycle": 6
    },
    {
      "name": "FunctionFieldData.div_algebraMap",
      "status": "AXIOM",
      "statement": "∀ c : k, div (algebraMap k K c) = 0",
      "approach": "Constants have zero divisor - structure field",
      "cycle": 6
    },
    {
      "name": "RRSpace.add_mem'",
      "status": "PROVED",
      "statement": "f ∈ L(D) → g ∈ L(D) → f + g ∈ L(D)",
      "approach": "Using div_add (strong triangle inequality)",
      "cycle": 6
    },
    {
      "name": "RRSpace.smul_mem'",
      "status": "PROVED",
      "statement": "c : k → f ∈ L(D) → c • f ∈ L(D)",
      "approach": "Using div_mul + div_algebraMap",
      "cycle": 6
    },
    {
      "name": "RRSpace (Submodule)",
      "status": "DEFINED",
      "statement": "def RRSpace (data : FunctionFieldData α k) (D : Divisor α) : Submodule k data.K",
      "approach": "Full k-submodule structure with zero_mem', add_mem', smul_mem'",
      "cycle": 6
    },
    {
      "name": "RRDataWithEuler.riemannRoch",
      "status": "DERIVED_FROM_ASSUMPTIONS",
      "statement": "∀ D, ℓ(D) - ℓ(K-D) = deg(D) + 1 - g",
      "approach": "Algebraic derivation from structure fields",
      "assumptions": [
        "serreDuality : ∀ D, ell (K - D) = h1 D",
        "eulerChar_def : ∀ D, eulerChar D = ell D - h1 D",
        "eulerChar_formula : ∀ D, eulerChar D = deg D + 1 - genus"
      ],
      "note": "eulerChar_formula IS Riemann-Roch; derivation is circular",
      "cycle": 3
    }
  ],
  "blockers": [
    "mathlib lacks: line bundles, sheaf cohomology H⁰/H¹, genus for schemes",
    "Cannot yet instantiate RRData.Div with Divisor α (needs point type from curve)",
    "RRData.deg is abstract; not yet connected to Divisor.deg",
    "RRData.ell is abstract; not yet connected to dim RRSpace"
  ],
  "resolved_blockers": [
    "PIVOT Cycle 2: defined RRData structure (elaborates)",
    "PIVOT Cycle 3: extended to RRDataWithEuler (RR derivable from fields)",
    "CYCLE 4: Defined Divisor α := α →₀ ℤ, proved deg_add/deg_zero/deg_neg/deg_sub/deg_single",
    "CYCLE 5: Defined Effective, FunctionFieldData, RRSpace L(D)",
    "CYCLE 6: L(D) is k-Submodule - added div_add, div_algebraMap, proved add_mem'/smul_mem'"
  ],
  "next_action": "Cycle 7: Define ℓ(D) = finrank k L(D), prove monotonicity"
}
