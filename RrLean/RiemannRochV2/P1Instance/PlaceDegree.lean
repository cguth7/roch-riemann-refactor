import RrLean.RiemannRochV2.Core.Basic
import RrLean.RiemannRochV2.Core.Divisor
import RrLean.RiemannRochV2.SerreDuality.P1Specific.RatFuncPairing
import RrLean.RiemannRochV2.Definitions.Infrastructure
import Mathlib.RingTheory.AdjoinRoot
import Mathlib.RingTheory.Polynomial.Quotient
import Mathlib.RingTheory.Coprime.Lemmas

/-!
# Place Degree for Polynomial Rings

This module defines the degree of a place (HeightOneSpectrum) for polynomial rings
over a field, and proves that it equals the residue field dimension.

## Main Definitions

* `PlaceDegree.degree` - The degree of a finite place as the finrank of its residue field
* `PlaceDegree.degWeighted` - Weighted degree of a divisor

## Key Results

* `finrank_residueField_eq_degree` - The residue field dimension equals the place degree
* `linearPlace_degree_eq_one` - Linear places have degree 1

## Strategy

For P¹ = RatFunc k, places are HeightOneSpectrum (Polynomial k). Each such place
corresponds to a monic irreducible polynomial p, and:
- The residue field is k[X]/(p), which has dimension deg(p) over k
- Using Mathlib's `finrank_quotient_span_eq_natDegree`, we get the dimension directly
-/

noncomputable section

namespace RiemannRochV2

namespace PlaceDegree

open IsDedekindDomain Polynomial

variable (k : Type*) [Field k] [DecidableEq k]

/-! ## Generator of a HeightOneSpectrum -/

/-- Every HeightOneSpectrum of k[X] is principal, generated by a monic irreducible.
This is because k[X] is a PID where every prime ideal is principal.

Proof: k[X] is a PID, so v.asIdeal = span{g} for some g.
Since v.asIdeal is prime and nonzero, g is irreducible.
Normalize to monic by scaling by (leadingCoeff g)⁻¹. -/
theorem exists_generator (v : HeightOneSpectrum (Polynomial k)) :
    ∃ p : Polynomial k, p.Monic ∧ Irreducible p ∧ v.asIdeal = Ideal.span {p} := by
  -- k[X] is a PID, so the prime ideal v.asIdeal is principal
  have hprinc : v.asIdeal.IsPrincipal := IsPrincipalIdealRing.principal v.asIdeal
  obtain ⟨g, hg⟩ := hprinc.principal
  -- g ≠ 0 since v.asIdeal ≠ ⊥
  have hg_ne : g ≠ 0 := by
    intro hg0
    have : v.asIdeal = ⊥ := by
      rw [hg, hg0]
      exact Submodule.span_singleton_eq_bot.mpr rfl
    exact v.ne_bot this
  -- g is irreducible since v.asIdeal is prime and nonzero in a PID
  have hg_irr : Irreducible g := by
    have hprime : v.asIdeal.IsPrime := v.isPrime
    rw [hg] at hprime
    have hprime' := (Ideal.span_singleton_prime hg_ne).mp hprime
    exact hprime'.irreducible
  -- Normalize to monic
  let u := leadingCoeff g
  have hu_ne : u ≠ 0 := leadingCoeff_ne_zero.mpr hg_ne
  use C u⁻¹ * g
  refine ⟨?monic, ?irr, ?span⟩
  case monic =>
    unfold Monic
    rw [leadingCoeff_mul, leadingCoeff_C, inv_mul_cancel₀ hu_ne]
  case irr =>
    have hCu_unit : IsUnit (C u⁻¹ : Polynomial k) := by
      rw [isUnit_C]
      exact (inv_ne_zero hu_ne).isUnit
    exact (irreducible_isUnit_mul hCu_unit).mpr hg_irr
  case span =>
    rw [hg]
    have hCu_unit : IsUnit (C u⁻¹ : Polynomial k) := by
      rw [isUnit_C]
      exact (inv_ne_zero hu_ne).isUnit
    -- span{C u⁻¹ * g} = span{g} since C u⁻¹ is a unit
    -- Convert Ideal.span to Submodule.span notation (they are equal by definition)
    simp only [← Ideal.submodule_span_eq]
    -- Now both sides are k[X] ∙ _, use span_singleton_eq_span_singleton
    rw [Submodule.span_singleton_eq_span_singleton]
    -- Need: ∃ z : (Polynomial k)ˣ, z • g = C u⁻¹ * g
    refine ⟨hCu_unit.unit, ?_⟩
    rw [Units.smul_def, IsUnit.unit_spec, smul_eq_mul]

/-- Choose a generator for a HeightOneSpectrum (monic irreducible polynomial). -/
noncomputable def generator (v : HeightOneSpectrum (Polynomial k)) : Polynomial k :=
  (exists_generator k v).choose

lemma generator_monic (v : HeightOneSpectrum (Polynomial k)) : (generator k v).Monic :=
  (exists_generator k v).choose_spec.1

lemma generator_irreducible (v : HeightOneSpectrum (Polynomial k)) : Irreducible (generator k v) :=
  (exists_generator k v).choose_spec.2.1

lemma asIdeal_eq_span_generator (v : HeightOneSpectrum (Polynomial k)) :
    v.asIdeal = Ideal.span {generator k v} :=
  (exists_generator k v).choose_spec.2.2

/-! ## Place Degree -/

/-- The degree of a finite place on Polynomial k is the natDegree of its generator.
This equals the residue field dimension [κ(v) : k]. -/
def degree (v : HeightOneSpectrum (Polynomial k)) : ℕ :=
  (generator k v).natDegree

/-- The degree is at least 1 for any place.

Proof: The generator is irreducible, and irreducible polynomials have degree ≥ 1.
Over a field, degree 0 polynomials are units, contradicting irreducibility. -/
lemma degree_pos (v : HeightOneSpectrum (Polynomial k)) : 0 < degree k v := by
  unfold degree
  have hirr := generator_irreducible k v
  -- Irreducible polynomials over a field have degree ≥ 1
  exact hirr.natDegree_pos

/-- Linear places have degree 1.

Proof: The generator and X - C α generate the same ideal, so they are associated.
Both are monic, so they must be equal. X - C α has natDegree 1. -/
lemma linearPlace_degree_eq_one (α : k) :
    degree k (linearPlace α) = 1 := by
  unfold degree
  have hgen := asIdeal_eq_span_generator k (linearPlace α)
  have hlin : (linearPlace α).asIdeal = Ideal.span {X - C α} := rfl
  rw [hlin] at hgen
  -- span{generator} = span{X - C α}, so they are associated
  have hassoc : Associated (generator k (linearPlace α)) (X - C α) := by
    rw [← Ideal.span_singleton_eq_span_singleton]
    exact hgen.symm
  have hmonic_gen := generator_monic k (linearPlace α)
  have hmonic_lin : (X - C α : Polynomial k).Monic := monic_X_sub_C α
  -- Associated monic polynomials are equal
  have heq : generator k (linearPlace α) = X - C α :=
    eq_of_monic_of_associated hmonic_gen hmonic_lin hassoc
  rw [heq, natDegree_X_sub_C]

/-- Places of degree 1 are linear places.

Proof: If degree(v) = 1, then generator(v) has natDegree 1.
Over a field, monic polynomials of degree 1 are of the form X - C α,
so v = linearPlace α for some α ∈ k.

This is the converse of `linearPlace_degree_eq_one`. -/
lemma linear_of_degree_eq_one (v : HeightOneSpectrum (Polynomial k)) (hdeg : degree k v = 1) :
    ∃ α : k, v = linearPlace α := by
  -- The generator has natDegree 1, so it's X - C α for some α
  -- Then v.asIdeal = span{X - C α} = (linearPlace α).asIdeal
  sorry

/-! ## Finrank of Residue Field -/

/-- The residue field of a place v has finrank equal to the place degree.
This uses Mathlib's `finrank_quotient_span_eq_natDegree`. -/
theorem finrank_residueField_eq_degree (v : HeightOneSpectrum (Polynomial k)) :
    Module.finrank k (Polynomial k ⧸ v.asIdeal) = degree k v := by
  rw [asIdeal_eq_span_generator k v]
  exact finrank_quotient_span_eq_natDegree

/-! ## Weighted Degree -/

/-- The weighted degree of a divisor, taking place degrees into account.
For D = Σ nᵥ · [v], this is Σ nᵥ · deg(v). -/
def degWeighted (D : DivisorV2 (Polynomial k)) : ℤ :=
  D.sum (fun v n => n * (degree k v : ℤ))

/-- For linear places, weighted degree equals unweighted degree. -/
lemma degWeighted_eq_deg_of_linear {D : DivisorV2 (Polynomial k)}
    (hlin : ∀ v ∈ D.support, degree k v = 1) :
    degWeighted k D = D.deg := by
  unfold degWeighted DivisorV2.deg
  apply Finsupp.sum_congr
  intro v hv
  rw [hlin v hv, Nat.cast_one, mul_one]

/-- Weighted degree of a single-place divisor. -/
lemma degWeighted_single (v : HeightOneSpectrum (Polynomial k)) (n : ℤ) :
    degWeighted k (DivisorV2.single v n) = n * (degree k v : ℤ) := by
  unfold degWeighted DivisorV2.single
  rw [Finsupp.sum_single_index (by ring)]

/-- Weighted degree is additive. -/
lemma degWeighted_add (D E : DivisorV2 (Polynomial k)) :
    degWeighted k (D + E) = degWeighted k D + degWeighted k E := by
  unfold degWeighted
  rw [Finsupp.sum_add_index']
  · intro v; ring
  · intro v n₁ n₂; ring

/-- Weighted degree of negation. -/
lemma degWeighted_neg (D : DivisorV2 (Polynomial k)) :
    degWeighted k (-D) = -degWeighted k D := by
  unfold degWeighted
  rw [Finsupp.sum_neg_index]
  · simp only [neg_mul, Finsupp.sum_neg]
  · intro _; ring

/-- Weighted degree is subtractive. -/
lemma degWeighted_sub (D E : DivisorV2 (Polynomial k)) :
    degWeighted k (D - E) = degWeighted k D - degWeighted k E := by
  rw [sub_eq_add_neg, degWeighted_add, degWeighted_neg, sub_eq_add_neg]

/-! ## Coprimality of Distinct Primes -/

/-- The generator of one prime is not in another prime ideal for distinct primes.

In k[X], distinct HeightOneSpectrum correspond to distinct monic irreducibles.
These generate coprime ideals. -/
lemma generator_not_mem_other_prime (v w : HeightOneSpectrum (Polynomial k))
    (hw : w ≠ v) : generator k v ∉ w.asIdeal := by
  -- If generator k v ∈ w.asIdeal, then v.asIdeal ⊆ w.asIdeal
  intro hgen_mem_w
  -- v.asIdeal = span{generator k v} ⊆ w.asIdeal
  have hv_le_w : v.asIdeal ≤ w.asIdeal := by
    rw [asIdeal_eq_span_generator k v]
    exact Ideal.span_le.mpr (Set.singleton_subset_iff.mpr hgen_mem_w)
  -- v.asIdeal is maximal (height-1 prime in k[X] is maximal)
  have hv_max := v.isMaximal
  -- w.asIdeal is prime and ≠ ⊤
  have hw_prime := w.isPrime
  -- By maximality: v.asIdeal ≤ w.asIdeal and w ≠ ⊤ implies v.asIdeal = w.asIdeal
  have heq : v.asIdeal = w.asIdeal := hv_max.eq_of_le hw_prime.ne_top hv_le_w
  -- But v.asIdeal ≠ w.asIdeal since hw : w ≠ v
  exact hw (HeightOneSpectrum.ext heq.symm)

/-- The generator of v has valuation 1 at other primes w ≠ v. -/
lemma generator_intValuation_at_other_prime (v w : HeightOneSpectrum (Polynomial k))
    (hw : w ≠ v) : w.intValuation (generator k v) = 1 := by
  rw [HeightOneSpectrum.intValuation_eq_one_iff]
  exact generator_not_mem_other_prime k v w hw

/-- The generator of v has v-adic valuation exp(-1).

This is the key lemma that connects generators to uniformizers.
Since v.asIdeal = span{generator}, and intValuation_singleton says
the valuation of a generator of the ideal is exp(-1), we're done. -/
lemma generator_intValuation_at_self (v : HeightOneSpectrum (Polynomial k)) :
    v.intValuation (generator k v) = WithZero.exp (-1 : ℤ) := by
  have hgen_ne : generator k v ≠ 0 := (generator_irreducible k v).ne_zero
  have hspan := asIdeal_eq_span_generator k v
  exact v.intValuation_singleton hgen_ne hspan

/-! ## Uniformizer-Generator Relationship

The abstract `uniformizerAt v` from Infrastructure.lean is defined as ANY element with
v.intValuation = exp(-1). In k[X], this could be `generator(v) * w` for some polynomial w
coprime to gen. The following lemmas establish the relationship needed for the
evaluation map surjectivity proof. -/

/-- The uniformizer is in v.asIdeal (has valuation < 1). -/
lemma uniformizerAt_mem_asIdeal (v : HeightOneSpectrum (Polynomial k)) :
    uniformizerAt v ∈ v.asIdeal := by
  rw [← v.intValuation_lt_one_iff_mem, uniformizerAt_val]
  -- exp(-1) < exp(0) = 1
  exact WithZero.exp_lt_exp.mpr (by norm_num : (-1 : ℤ) < 0)

/-- The uniformizer is not in v.asIdeal² (has valuation exactly exp(-1), not exp(-2)). -/
lemma uniformizerAt_not_mem_asIdeal_sq (v : HeightOneSpectrum (Polynomial k)) :
    uniformizerAt v ∉ v.asIdeal ^ 2 := by
  intro h
  have hval := uniformizerAt_val v
  -- If π ∈ v.asIdeal², then v(π) ≤ exp(-2)
  have hval_le : v.intValuation (uniformizerAt v) ≤ WithZero.exp (-2 : ℤ) :=
    (v.intValuation_le_pow_iff_mem (uniformizerAt v) 2).mpr h
  rw [hval] at hval_le
  -- exp(-1) ≤ exp(-2) is false since -1 > -2
  have hcontra : (-1 : ℤ) ≤ -2 := WithZero.exp_le_exp.mp hval_le
  omega

/-- The generator divides the uniformizer in k[X]. -/
lemma generator_dvd_uniformizerAt (v : HeightOneSpectrum (Polynomial k)) :
    generator k v ∣ uniformizerAt v := by
  have hmem := uniformizerAt_mem_asIdeal k v
  rw [asIdeal_eq_span_generator k v, Ideal.mem_span_singleton] at hmem
  exact hmem

/-- The quotient w = uniformizerAt / generator (using polynomial division). -/
noncomputable def uniformizerQuotient (v : HeightOneSpectrum (Polynomial k)) : Polynomial k :=
  uniformizerAt v /ₘ generator k v

/-- Key: uniformizerAt = generator * uniformizerQuotient. -/
lemma uniformizerAt_eq_generator_mul_quotient (v : HeightOneSpectrum (Polynomial k)) :
    uniformizerAt v = generator k v * uniformizerQuotient k v := by
  have hmonic := generator_monic k v
  have hdvd := generator_dvd_uniformizerAt k v
  rw [uniformizerQuotient]
  -- For monic divisor, p %ₘ d + d * (p /ₘ d) = p, and when d | p, p %ₘ d = 0
  have hmod_zero : uniformizerAt v %ₘ generator k v = 0 := by
    rw [Polynomial.modByMonic_eq_zero_iff_dvd hmonic]
    exact hdvd
  have hdiv := Polynomial.modByMonic_add_div (uniformizerAt v) hmonic
  -- hdiv : uniformizerAt v %ₘ gen + gen * (uniformizerAt v /ₘ gen) = uniformizerAt v
  rw [hmod_zero, zero_add] at hdiv
  exact hdiv.symm

/-- The quotient w is not in v.asIdeal (equivalently, gcd(w, gen) = 1). -/
lemma uniformizerQuotient_not_mem_asIdeal (v : HeightOneSpectrum (Polynomial k)) :
    uniformizerQuotient k v ∉ v.asIdeal := by
  intro hw_mem
  apply uniformizerAt_not_mem_asIdeal_sq k v
  rw [uniformizerAt_eq_generator_mul_quotient k v]
  -- gen * w ∈ v.asIdeal² when w ∈ v.asIdeal
  rw [pow_two]
  apply Ideal.mul_mem_mul
  · rw [asIdeal_eq_span_generator k v]
    exact Ideal.mem_span_singleton_self _
  · exact hw_mem

/-- The quotient w is nonzero. -/
lemma uniformizerQuotient_ne_zero (v : HeightOneSpectrum (Polynomial k)) :
    uniformizerQuotient k v ≠ 0 := by
  intro hw_zero
  have heq := uniformizerAt_eq_generator_mul_quotient k v
  rw [hw_zero, mul_zero] at heq
  exact uniformizerAt_ne_zero v heq

/-- In K = RatFunc k, uniformizerAt / generator = uniformizerQuotient. -/
lemma uniformizerAt_div_generator_eq_quotient (v : HeightOneSpectrum (Polynomial k)) :
    algebraMap (Polynomial k) (RatFunc k) (uniformizerAt v) /
    algebraMap (Polynomial k) (RatFunc k) (generator k v) =
    algebraMap (Polynomial k) (RatFunc k) (uniformizerQuotient k v) := by
  have hgen_ne : (generator k v) ≠ 0 := (generator_irreducible k v).ne_zero
  have hgen_K_ne : algebraMap (Polynomial k) (RatFunc k) (generator k v) ≠ 0 :=
    RatFunc.algebraMap_ne_zero hgen_ne
  rw [uniformizerAt_eq_generator_mul_quotient k v, map_mul]
  field_simp

/-- The residue of uniformizerQuotient in κ(v) is nonzero (hence invertible). -/
lemma uniformizerQuotient_residue_ne_zero (v : HeightOneSpectrum (Polynomial k)) :
    Ideal.Quotient.mk v.asIdeal (uniformizerQuotient k v) ≠ 0 := by
  rw [ne_eq, Ideal.Quotient.eq_zero_iff_mem]
  exact uniformizerQuotient_not_mem_asIdeal k v

/-! ## Valuation-Degree Relationship

The key lemmas connecting valuations at places to polynomial degrees.
For polynomial p over field k:
- val_v(p) ≤ exp(-n) iff generator_v^n | p
- If generator_v^n | p, then p.natDegree ≥ n * deg(v)
-/

/-- The n-th power of v.asIdeal equals span{generator^n}. -/
lemma asIdeal_pow_eq_span_generator_pow (v : HeightOneSpectrum (Polynomial k)) (n : ℕ) :
    v.asIdeal ^ n = Ideal.span {generator k v ^ n} := by
  rw [asIdeal_eq_span_generator k v, Ideal.span_singleton_pow]

/-- Membership in v.asIdeal^n is equivalent to generator^n dividing the element. -/
lemma mem_asIdeal_pow_iff_generator_pow_dvd (v : HeightOneSpectrum (Polynomial k))
    (p : Polynomial k) (n : ℕ) :
    p ∈ v.asIdeal ^ n ↔ generator k v ^ n ∣ p := by
  rw [asIdeal_pow_eq_span_generator_pow k v n, Ideal.mem_span_singleton]

/-- If g^n divides p (g monic, p nonzero), then p.natDegree ≥ n * g.natDegree. -/
lemma natDegree_ge_of_pow_dvd {g p : Polynomial k} (hg_monic : g.Monic)
    (hp_ne : p ≠ 0) (n : ℕ) (hdvd : g ^ n ∣ p) :
    p.natDegree ≥ n * g.natDegree := by
  obtain ⟨q, hpq⟩ := hdvd
  have hq_ne : q ≠ 0 := by
    intro hq0
    rw [hq0, mul_zero] at hpq
    exact hp_ne hpq
  have hgn_monic : (g ^ n).Monic := hg_monic.pow n
  have hgn_ne : g ^ n ≠ 0 := hgn_monic.ne_zero
  calc p.natDegree = (g ^ n * q).natDegree := by rw [hpq]
    _ = (g ^ n).natDegree + q.natDegree := by
        rw [natDegree_mul hgn_ne hq_ne]
    _ ≥ (g ^ n).natDegree := Nat.le_add_right _ _
    _ = n * g.natDegree := by rw [natDegree_pow]

/-- Key lemma: If val_v(p) ≤ exp(-n), then p.natDegree ≥ n * deg(v).

This connects the v-adic valuation to polynomial degree bounds. -/
lemma natDegree_ge_of_intValuation_le (v : HeightOneSpectrum (Polynomial k))
    (p : Polynomial k) (hp_ne : p ≠ 0) (n : ℕ)
    (hval : v.intValuation p ≤ WithZero.exp (-(n : ℤ))) :
    p.natDegree ≥ n * degree k v := by
  -- Valuation bound implies membership in ideal power
  rw [v.intValuation_le_pow_iff_mem] at hval
  -- Membership in ideal power implies generator^n divides p
  rw [mem_asIdeal_pow_iff_generator_pow_dvd] at hval
  -- Apply the degree bound lemma
  exact natDegree_ge_of_pow_dvd k (generator_monic k v) hp_ne n hval

/-- For effective divisors, degWeighted ≥ deg since all place degrees are ≥ 1. -/
lemma degWeighted_ge_deg (D : DivisorV2 (Polynomial k)) (hD_eff : D.Effective) :
    degWeighted k D ≥ D.deg := by
  unfold degWeighted DivisorV2.deg
  apply Finsupp.sum_le_sum
  intro v _
  have hdeg_pos : degree k v ≥ 1 := degree_pos k v
  have hDv : D v ≥ 0 := hD_eff v
  have hdeg_ge_one : (degree k v : ℤ) ≥ 1 := by simp only [ge_iff_le]; omega
  calc D v * (degree k v : ℤ)
      ≥ D v * 1 := by
        apply mul_le_mul_of_nonneg_left hdeg_ge_one hDv
    _ = D v := by ring

/-- Sum version: If val_v(p) ≤ exp(-D(v)) for all v in support of D,
then p.natDegree ≥ D.degWeighted (sum of D(v) * deg(v)).

This is the key lemma for proving L(K-D) vanishing.

Proof sketch: Each valuation bound val_v(p) ≤ exp(-D(v)) means gen_v^{D(v)} | p.
Since generators at different places are coprime, their product divides p.
The degree of this product equals degWeighted k D, giving the bound. -/
lemma natDegree_ge_degWeighted_of_valuation_bounds (D : DivisorV2 (Polynomial k))
    (hD_eff : D.Effective) (p : Polynomial k) (hp_ne : p ≠ 0)
    (hval : ∀ v ∈ D.support, v.intValuation p ≤ WithZero.exp (-(D v : ℤ))) :
    (p.natDegree : ℤ) ≥ degWeighted k D := by
  -- First, if D.support is empty, degWeighted = 0 and the bound is trivial
  by_cases hsupp : D.support = ∅
  · rw [Finsupp.support_eq_empty] at hsupp
    simp only [hsupp, degWeighted, Finsupp.sum_zero_index]
    exact Nat.cast_nonneg _
  -- For nonempty support: each gen_v^{D(v)} divides p (from valuation bound)
  have hdvd_each : ∀ v ∈ D.support, generator k v ^ (D v).toNat ∣ p := by
    intro v hv
    have hDv_pos : D v ≥ 0 := hD_eff v
    have hval_v := hval v hv
    -- Convert: D v = (D v).toNat as integers when D v ≥ 0
    have hDv_eq : (D v : ℤ) = ((D v).toNat : ℤ) := (Int.toNat_of_nonneg hDv_pos).symm
    rw [hDv_eq] at hval_v
    rw [v.intValuation_le_pow_iff_mem, mem_asIdeal_pow_iff_generator_pow_dvd] at hval_v
    exact hval_v
  -- Generators at different places are coprime
  have hcoprime_gen : ∀ v ∈ D.support, ∀ w ∈ D.support, v ≠ w →
      IsCoprime (generator k v) (generator k w) := by
    intro v _ w _ hvw
    -- generator k v ∉ w.asIdeal, so generator k w ∤ generator k v
    have hnotdvd : ¬(generator k w ∣ generator k v) := by
      intro hdvd
      have hmem : generator k v ∈ w.asIdeal := by
        rw [asIdeal_eq_span_generator k w, Ideal.mem_span_singleton]
        exact hdvd
      exact generator_not_mem_other_prime k v w hvw.symm hmem
    -- Distinct irreducibles are coprime
    exact isCoprime_comm.mp ((generator_irreducible k w).coprime_iff_not_dvd.mpr hnotdvd)
  -- Powers of coprime elements are coprime
  have hcoprime_pow : (D.support : Set (HeightOneSpectrum (Polynomial k))).Pairwise
      (fun v w => IsCoprime (generator k v ^ (D v).toNat) (generator k w ^ (D w).toNat)) := by
    intro v hv w hw hvw
    exact (hcoprime_gen v hv w hw hvw).pow
  -- Product of coprime divisors divides p
  have hprod_dvd : (∏ v ∈ D.support, generator k v ^ (D v).toNat) ∣ p :=
    Finset.prod_dvd_of_coprime hcoprime_pow hdvd_each
  -- Product is monic
  have hprod_monic : (∏ v ∈ D.support, generator k v ^ (D v).toNat).Monic :=
    monic_prod_of_monic _ _ (fun v _ => (generator_monic k v).pow (D v).toNat)
  -- Degree of product = sum of degrees
  have hdeg_prod : (∏ v ∈ D.support, generator k v ^ (D v).toNat).natDegree =
      ∑ v ∈ D.support, (generator k v ^ (D v).toNat).natDegree :=
    natDegree_prod_of_monic _ _ (fun v _ => (generator_monic k v).pow (D v).toNat)
  -- Each term: natDegree(gen^n) = n * natDegree(gen) = n * deg(v)
  have hdeg_pow : ∀ v ∈ D.support, (generator k v ^ (D v).toNat).natDegree =
      (D v).toNat * degree k v := fun v _ => natDegree_pow _ _
  -- Sum of natDegrees = degWeighted (via cast to ℤ)
  have hprod_deg : ((∏ v ∈ D.support, generator k v ^ (D v).toNat).natDegree : ℤ) =
      degWeighted k D := by
    rw [hdeg_prod]
    unfold degWeighted
    rw [Finsupp.sum]
    simp only [Nat.cast_sum]
    apply Finset.sum_congr rfl
    intro v hv
    rw [hdeg_pow v hv]
    have hDv_pos : D v ≥ 0 := hD_eff v
    simp only [Nat.cast_mul, Int.toNat_of_nonneg hDv_pos]
  -- Final bound: p.natDegree ≥ product.natDegree = degWeighted
  obtain ⟨q, hpq⟩ := hprod_dvd
  have hq_ne : q ≠ 0 := by
    intro hq0
    rw [hq0, mul_zero] at hpq
    exact hp_ne hpq
  have hprod_ne : (∏ v ∈ D.support, generator k v ^ (D v).toNat) ≠ 0 := hprod_monic.ne_zero
  have hge : p.natDegree ≥ (∏ v ∈ D.support, generator k v ^ (D v).toNat).natDegree := by
    calc p.natDegree
        = ((∏ v ∈ D.support, generator k v ^ (D v).toNat) * q).natDegree := by rw [← hpq]
      _ = (∏ v ∈ D.support, generator k v ^ (D v).toNat).natDegree + q.natDegree := by
          rw [natDegree_mul hprod_ne hq_ne]
      _ ≥ (∏ v ∈ D.support, generator k v ^ (D v).toNat).natDegree := Nat.le_add_right _ _
  calc (p.natDegree : ℤ)
      ≥ (∏ v ∈ D.support, generator k v ^ (D v).toNat).natDegree := by exact_mod_cast hge
    _ = degWeighted k D := hprod_deg

/-! ## Polynomial Degree as Sum of Multiplicities

The fundamental theorem relating polynomial degree to place multiplicities.
For p ≠ 0: p.natDegree = Σ_v ord_v(p) * deg(v)

This comes from unique factorization: p = u * ∏_v generator(v)^{ord_v(p)}
where u is the leading coefficient (a unit in k).
-/

/-- For a rational function f = num/denom, the intDegree bounds relate to valuations.

**Key insight**: At each place v:
- val_v(f) = exp(ord_v(denom) - ord_v(num)) where ord_v is the multiplicity
- The constraint val_v(f) ≤ exp(-D(v)) means ord_v(num) - ord_v(denom) ≥ D(v)

For polynomials p ≠ 0, natDegree(p) = Σ_v ord_v(p) * deg(v) (sum over all zeros).

With IsLinearPlaceSupport (deg(v) = 1 for all v ∈ D.support), this becomes:
- intDegree(f) = Σ (ord_v(num) - ord_v(denom))
              ≥ Σ D(v) = D.deg

**Mathematical proof outline**:
1. By unique factorization: p = u * ∏ gen_v^{ord_v(p)} where u is the leading coeff
2. natDegree(p) = Σ ord_v(p) * natDegree(gen_v) = Σ ord_v(p) * deg(v)
3. For f = num/denom: intDegree = num.natDegree - denom.natDegree
                                 = Σ ord_v(num) * deg(v) - Σ ord_v(denom) * deg(v)
4. With IsLinearPlaceSupport: deg(v) = 1 for v ∈ D.support
5. Using constraints: intDegree ≥ Σ D(v) = D.deg
-/
theorem intDegree_ge_deg_of_valuation_bounds_and_linear_support
    (D : DivisorV2 (Polynomial k)) (f : RatFunc k) (hf : f ≠ 0)
    (hf_val : ∀ v, v.valuation (RatFunc k) f ≤ WithZero.exp (-D v))
    (hdenom_only_neg : ∀ v, f.denom ∈ v.asIdeal → D v < 0)
    (hlin : ∀ v ∈ D.support, degree k v = 1) :
    f.intDegree ≥ D.deg := by
  /-
  **Proof Strategy (Cycle 302)**:

  1. **Numerator lower bound**: Define E = D.posPart (positive part of D).
     - At v ∈ E.support: D(v) > 0, so denom ∉ v.asIdeal (by hdenom_only_neg)
     - Hence val_v(num) = val_v(f) ≤ exp(-D(v)) = exp(-E(v))
     - Apply `natDegree_ge_degWeighted_of_valuation_bounds` to get num.natDegree ≥ E.deg

  2. **Denominator upper bound**:
     - Denom zeros only at D(v) < 0 places (from hdenom_only_neg)
     - These places have degree 1 (from hlin), so all irreducible factors are linear
     - Hence denom splits completely
     - Each root α has rootMult(α) ≤ |D(linearPlace α)| by valuation constraint + coprimality
     - Sum: denom.natDegree = Σ rootMult ≤ Σ |D(v)| = D.negPart.deg

  3. **Combine**:
     intDegree = num.natDegree - denom.natDegree
               ≥ D.posPart.deg - D.negPart.deg
               = D.deg

  **Dependencies**:
  - `linear_of_degree_eq_one`: Places of degree 1 are linear (needs proof)
  - `intValuation_linearPlace_eq_exp_neg_rootMultiplicity`: Bridge from valuation to rootMult
  - `Splits.natDegree_eq_card_roots`: For split polynomials, natDegree = roots.card
  -/
  sorry

end PlaceDegree

end RiemannRochV2
