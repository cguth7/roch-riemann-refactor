{
  "active_edge": "Genus 0 special cases and high-degree exactness",
  "candidates": [
    {
      "name": "Divisor α",
      "status": "PROVED",
      "statement": "abbrev Divisor (α : Type*) := α →₀ ℤ",
      "approach": "Type alias for Finsupp",
      "cycle": 4
    },
    {
      "name": "Divisor.deg",
      "status": "PROVED",
      "statement": "def deg (D : Divisor α) : ℤ := D.sum (fun _ n => n)",
      "approach": "Sum of coefficients",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_add",
      "status": "PROVED",
      "statement": "deg (D + E) = deg D + deg E",
      "approach": "Via Finsupp.sum_add_index'",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_zero",
      "status": "PROVED",
      "statement": "deg 0 = 0",
      "approach": "Via Finsupp.sum_zero_index",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_neg",
      "status": "PROVED",
      "statement": "deg (-D) = -deg D",
      "approach": "Derived from deg_add + omega",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_sub",
      "status": "PROVED",
      "statement": "deg (D - E) = deg D - deg E",
      "approach": "Derived from deg_add + deg_neg",
      "cycle": 4
    },
    {
      "name": "Divisor.deg_single",
      "status": "PROVED",
      "statement": "deg (single p n) = n",
      "approach": "Via Finsupp.sum_single_index",
      "cycle": 4
    },
    {
      "name": "Divisor.Effective",
      "status": "PROVED",
      "statement": "def Effective (D : Divisor α) : Prop := 0 ≤ D",
      "approach": "Uses mathlib's Finsupp pointwise order",
      "cycle": 5
    },
    {
      "name": "FunctionFieldData",
      "status": "DEFINED",
      "statement": "structure FunctionFieldData (α : Type*) with K, div, div_mul, div_one, div_inv, deg_div",
      "approach": "Axiomatizes function field with principal divisor map",
      "cycle": 5
    },
    {
      "name": "RRSpace (Submodule)",
      "status": "DEFINED",
      "statement": "def RRSpace (data : FunctionFieldData α k) (D : Divisor α) : Submodule k data.K",
      "approach": "Full k-submodule structure with zero_mem', add_mem', smul_mem'",
      "cycle": 6
    },
    {
      "name": "ell",
      "status": "DEFINED",
      "statement": "def ell (data : FunctionFieldData α k) (D : Divisor α) := Module.finrank k (RRSpace data D)",
      "approach": "Semantic dimension using mathlib's finrank",
      "cycle": 7
    },
    {
      "name": "FunctionFieldDataWithBound",
      "status": "DEFINED",
      "statement": "structure extending FunctionFieldData with single_point_bound : ∀ D p, ell (D + p) ≤ ell D + 1",
      "approach": "Axiomatize single-point dimension bound",
      "cycle": 10
    },
    {
      "name": "ell.le_deg_add_ell_zero_from_bound",
      "status": "PROVED",
      "statement": "Effective D → (ell data D : ℤ) ≤ deg D + ell data 0",
      "approach": "RIEMANN INEQUALITY - degree induction",
      "cycle": 11
    },
    {
      "name": "FunctionFieldDataWithRR",
      "status": "DEFINED",
      "statement": "structure extending FunctionFieldDataWithBound with genus, K_div, deg_K, rr_axiom",
      "approach": "Axiomatize full Riemann-Roch as structure fields",
      "cycle": 12
    },
    {
      "name": "FunctionFieldDataWithRR.riemannRoch_eq",
      "status": "PROVED",
      "statement": "ℓ(D) - ℓ(K-D) = deg D + 1 - g",
      "approach": "Direct application of rr_axiom",
      "cycle": 12
    },
    {
      "name": "FunctionFieldDataWithRR.ell_K",
      "status": "PROVED",
      "statement": "ℓ(K) = g",
      "approach": "Apply RR to D = K, use ℓ(0) = 1 and deg(K) = 2g-2",
      "cycle": 12
    },
    {
      "name": "FunctionFieldDataWithRR.ell_K_sub_D_eq_zero_of_deg_gt",
      "status": "PROVED",
      "statement": "deg D > 2g - 2 → ℓ(K-D) = 0",
      "approach": "Vanishing via deg_div semantic content",
      "cycle": 12
    }
  ],
  "cycle_14_candidates": [
    {
      "name": "FunctionFieldDataWithRR.deg_K_genus_zero",
      "status": "PROVED",
      "statement": "genus = 0 → deg K_div = -2",
      "approach": "deg_K axiom + h_genus = 0",
      "cycle": 14
    },
    {
      "name": "FunctionFieldDataWithRR.ell_K_genus_zero",
      "status": "PROVED",
      "statement": "genus = 0 → ℓ(K) = 0",
      "approach": "ell_K lemma + h_genus = 0",
      "cycle": 14
    },
    {
      "name": "FunctionFieldDataWithRR.ell_eq_deg_minus_genus_of_deg_gt",
      "status": "PROVED",
      "statement": "deg D > 2g - 2 → ℓ(D) = deg D + 1 - g",
      "approach": "RR + vanishing theorem (high-degree exactness)",
      "cycle": 14
    },
    {
      "name": "FunctionFieldDataWithRR.ell_eq_deg_succ_of_genus_zero_deg_gt",
      "status": "PROVED",
      "statement": "genus = 0 → deg D > -2 → ℓ(D) = deg D + 1",
      "approach": "Special case of ell_eq_deg_minus_genus_of_deg_gt",
      "cycle": 14
    },
    {
      "name": "FunctionFieldDataWithRR.ell_eq_deg_succ_of_genus_zero_effective",
      "status": "PROVED",
      "statement": "genus = 0 → Effective D → ℓ(D) = deg(D).toNat + 1",
      "approach": "Natural number version for effective divisors",
      "cycle": 14
    },
    {
      "name": "FunctionFieldDataWithRR.ell_le_deg_succ_of_deg_gt",
      "status": "PROVED",
      "statement": "deg D > 2g - 2 → ℓ(D) ≤ deg D + 1",
      "approach": "Upper bound from ell_eq_deg_minus_genus_of_deg_gt + genus ≥ 0",
      "cycle": 14
    },
    {
      "name": "FunctionFieldDataWithRR.ell_zero_of_genus_zero_deg_neg_one",
      "status": "PROVED",
      "statement": "genus = 0 → deg D = -1 → ℓ(D) = 0",
      "approach": "Boundary case: deg = -1 > -2 gives exactness with ℓ = 0",
      "cycle": 14
    },
    {
      "name": "FunctionFieldDataWithRR.clifford_bound",
      "status": "BLOCKED",
      "statement": "ℓ(D) ≥ 2 → ℓ(K-D) ≥ 2 → 2·ℓ(D) ≤ deg D + 2",
      "approach": "Requires multiplication axiom for sections (geometric argument)",
      "blocker": "Clifford's inequality needs additional structure beyond RR axiom",
      "cycle": 14
    }
  ],
  "blockers": [
    "mathlib lacks: line bundles, sheaf cohomology H⁰/H¹, genus for schemes",
    "Base RRData.riemannRoch has no proof path without additional structure axioms",
    "Clifford's theorem requires multiplication map on sections (not provable from RR alone)"
  ],
  "resolved_blockers": [
    "CYCLE 4-6: Divisor foundations, FunctionFieldData, RRSpace as k-Submodule",
    "CYCLE 7-8: ell(D) = finrank, finite-dimensionality via typeclass",
    "CYCLE 9: Quotient infrastructure for dimension bounds",
    "CYCLE 10: FunctionFieldDataWithBound axiom extension",
    "CYCLE 11: Riemann inequality PROVED via degree induction",
    "CYCLE 12: Full FunctionFieldDataWithRR structure, 7 lemmas PROVED",
    "CYCLE 13: Cleanup - removed 4 superseded sorries",
    "CYCLE 14: Genus 0 special cases - 7 lemmas PROVED"
  ],
  "next_action": "Cycle 15: Consider Clifford axiom extension or RRData instantiation"
}
