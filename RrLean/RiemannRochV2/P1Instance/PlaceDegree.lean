import RrLean.RiemannRochV2.Core.Basic
import RrLean.RiemannRochV2.Core.Divisor
import RrLean.RiemannRochV2.SerreDuality.P1Specific.RatFuncPairing
import Mathlib.RingTheory.AdjoinRoot
import Mathlib.RingTheory.Polynomial.Quotient

/-!
# Place Degree for Polynomial Rings

This module defines the degree of a place (HeightOneSpectrum) for polynomial rings
over a field, and proves that it equals the residue field dimension.

## Main Definitions

* `PlaceDegree.degree` - The degree of a finite place as the finrank of its residue field
* `PlaceDegree.degWeighted` - Weighted degree of a divisor

## Key Results

* `finrank_residueField_eq_degree` - The residue field dimension equals the place degree
* `linearPlace_degree_eq_one` - Linear places have degree 1

## Strategy

For P¹ = RatFunc k, places are HeightOneSpectrum (Polynomial k). Each such place
corresponds to a monic irreducible polynomial p, and:
- The residue field is k[X]/(p), which has dimension deg(p) over k
- Using Mathlib's `finrank_quotient_span_eq_natDegree`, we get the dimension directly
-/

noncomputable section

namespace RiemannRochV2

namespace PlaceDegree

open IsDedekindDomain Polynomial

variable (k : Type*) [Field k] [DecidableEq k]

/-! ## Generator of a HeightOneSpectrum -/

/-- Every HeightOneSpectrum of k[X] is principal, generated by a monic irreducible.
This is because k[X] is a PID where every prime ideal is principal.

Proof: k[X] is a PID, so v.asIdeal = span{g} for some g.
Since v.asIdeal is prime and nonzero, g is irreducible.
Normalize to monic by scaling by (leadingCoeff g)⁻¹. -/
theorem exists_generator (v : HeightOneSpectrum (Polynomial k)) :
    ∃ p : Polynomial k, p.Monic ∧ Irreducible p ∧ v.asIdeal = Ideal.span {p} := by
  -- k[X] is a PID, so the prime ideal v.asIdeal is principal
  have hprinc : v.asIdeal.IsPrincipal := IsPrincipalIdealRing.principal v.asIdeal
  obtain ⟨g, hg⟩ := hprinc.principal
  -- g ≠ 0 since v.asIdeal ≠ ⊥
  have hg_ne : g ≠ 0 := by
    intro hg0
    have : v.asIdeal = ⊥ := by
      rw [hg, hg0]
      exact Submodule.span_singleton_eq_bot.mpr rfl
    exact v.ne_bot this
  -- g is irreducible since v.asIdeal is prime and nonzero in a PID
  have hg_irr : Irreducible g := by
    have hprime : v.asIdeal.IsPrime := v.isPrime
    rw [hg] at hprime
    have hprime' := (Ideal.span_singleton_prime hg_ne).mp hprime
    exact hprime'.irreducible
  -- Normalize to monic
  let u := leadingCoeff g
  have hu_ne : u ≠ 0 := leadingCoeff_ne_zero.mpr hg_ne
  use C u⁻¹ * g
  refine ⟨?monic, ?irr, ?span⟩
  case monic =>
    unfold Monic
    rw [leadingCoeff_mul, leadingCoeff_C, inv_mul_cancel₀ hu_ne]
  case irr =>
    have hCu_unit : IsUnit (C u⁻¹ : Polynomial k) := by
      rw [isUnit_C]
      exact (inv_ne_zero hu_ne).isUnit
    exact (irreducible_isUnit_mul hCu_unit).mpr hg_irr
  case span =>
    rw [hg]
    have hCu_unit : IsUnit (C u⁻¹ : Polynomial k) := by
      rw [isUnit_C]
      exact (inv_ne_zero hu_ne).isUnit
    -- span{C u⁻¹ * g} = span{g} since C u⁻¹ is a unit
    -- Convert Ideal.span to Submodule.span notation (they are equal by definition)
    simp only [← Ideal.submodule_span_eq]
    -- Now both sides are k[X] ∙ _, use span_singleton_eq_span_singleton
    rw [Submodule.span_singleton_eq_span_singleton]
    -- Need: ∃ z : (Polynomial k)ˣ, z • g = C u⁻¹ * g
    refine ⟨hCu_unit.unit, ?_⟩
    rw [Units.smul_def, IsUnit.unit_spec, smul_eq_mul]

/-- Choose a generator for a HeightOneSpectrum (monic irreducible polynomial). -/
noncomputable def generator (v : HeightOneSpectrum (Polynomial k)) : Polynomial k :=
  (exists_generator k v).choose

lemma generator_monic (v : HeightOneSpectrum (Polynomial k)) : (generator k v).Monic :=
  (exists_generator k v).choose_spec.1

lemma generator_irreducible (v : HeightOneSpectrum (Polynomial k)) : Irreducible (generator k v) :=
  (exists_generator k v).choose_spec.2.1

lemma asIdeal_eq_span_generator (v : HeightOneSpectrum (Polynomial k)) :
    v.asIdeal = Ideal.span {generator k v} :=
  (exists_generator k v).choose_spec.2.2

/-! ## Place Degree -/

/-- The degree of a finite place on Polynomial k is the natDegree of its generator.
This equals the residue field dimension [κ(v) : k]. -/
def degree (v : HeightOneSpectrum (Polynomial k)) : ℕ :=
  (generator k v).natDegree

/-- The degree is at least 1 for any place.

Proof: The generator is irreducible, and irreducible polynomials have degree ≥ 1.
Over a field, degree 0 polynomials are units, contradicting irreducibility. -/
lemma degree_pos (v : HeightOneSpectrum (Polynomial k)) : 0 < degree k v := by
  unfold degree
  have hirr := generator_irreducible k v
  -- Irreducible polynomials over a field have degree ≥ 1
  exact hirr.natDegree_pos

/-- Linear places have degree 1.

Proof: The generator and X - C α generate the same ideal, so they are associated.
Both are monic, so they must be equal. X - C α has natDegree 1. -/
lemma linearPlace_degree_eq_one (α : k) :
    degree k (linearPlace α) = 1 := by
  unfold degree
  have hgen := asIdeal_eq_span_generator k (linearPlace α)
  have hlin : (linearPlace α).asIdeal = Ideal.span {X - C α} := rfl
  rw [hlin] at hgen
  -- span{generator} = span{X - C α}, so they are associated
  have hassoc : Associated (generator k (linearPlace α)) (X - C α) := by
    rw [← Ideal.span_singleton_eq_span_singleton]
    exact hgen.symm
  have hmonic_gen := generator_monic k (linearPlace α)
  have hmonic_lin : (X - C α : Polynomial k).Monic := monic_X_sub_C α
  -- Associated monic polynomials are equal
  have heq : generator k (linearPlace α) = X - C α :=
    eq_of_monic_of_associated hmonic_gen hmonic_lin hassoc
  rw [heq, natDegree_X_sub_C]

/-! ## Finrank of Residue Field -/

/-- The residue field of a place v has finrank equal to the place degree.
This uses Mathlib's `finrank_quotient_span_eq_natDegree`. -/
theorem finrank_residueField_eq_degree (v : HeightOneSpectrum (Polynomial k)) :
    Module.finrank k (Polynomial k ⧸ v.asIdeal) = degree k v := by
  rw [asIdeal_eq_span_generator k v]
  exact finrank_quotient_span_eq_natDegree

/-! ## Weighted Degree -/

/-- The weighted degree of a divisor, taking place degrees into account.
For D = Σ nᵥ · [v], this is Σ nᵥ · deg(v). -/
def degWeighted (D : DivisorV2 (Polynomial k)) : ℤ :=
  D.sum (fun v n => n * (degree k v : ℤ))

/-- For linear places, weighted degree equals unweighted degree. -/
lemma degWeighted_eq_deg_of_linear {D : DivisorV2 (Polynomial k)}
    (hlin : ∀ v ∈ D.support, degree k v = 1) :
    degWeighted k D = D.deg := by
  unfold degWeighted DivisorV2.deg
  apply Finsupp.sum_congr
  intro v hv
  rw [hlin v hv, Nat.cast_one, mul_one]

/-- Weighted degree of a single-place divisor. -/
lemma degWeighted_single (v : HeightOneSpectrum (Polynomial k)) (n : ℤ) :
    degWeighted k (DivisorV2.single v n) = n * (degree k v : ℤ) := by
  unfold degWeighted DivisorV2.single
  rw [Finsupp.sum_single_index (by ring)]

/-- Weighted degree is additive. -/
lemma degWeighted_add (D E : DivisorV2 (Polynomial k)) :
    degWeighted k (D + E) = degWeighted k D + degWeighted k E := by
  unfold degWeighted
  rw [Finsupp.sum_add_index']
  · intro v; ring
  · intro v n₁ n₂; ring

/-- Weighted degree of negation. -/
lemma degWeighted_neg (D : DivisorV2 (Polynomial k)) :
    degWeighted k (-D) = -degWeighted k D := by
  unfold degWeighted
  rw [Finsupp.sum_neg_index]
  · simp only [neg_mul, Finsupp.sum_neg]
  · intro _; ring

/-- Weighted degree is subtractive. -/
lemma degWeighted_sub (D E : DivisorV2 (Polynomial k)) :
    degWeighted k (D - E) = degWeighted k D - degWeighted k E := by
  rw [sub_eq_add_neg, degWeighted_add, degWeighted_neg, sub_eq_add_neg]

end PlaceDegree

end RiemannRochV2
